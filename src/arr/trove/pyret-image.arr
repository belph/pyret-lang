provide {
  rgba-color : IM_D.rgba-color,
  rgb-color : IM_D.rgb-color,
  orangered : IM_D.orangered,
  tomato : IM_D.tomato,
  darkred : IM_D.darkred,
  red : IM_D.red,
  firebrick : IM_D.firebrick,
  crimson : IM_D.crimson,
  deeppink : IM_D.deeppink,
  maroon : IM_D.maroon,
  indianred : IM_D.indianred,
  mediumvioletred : IM_D.mediumvioletred,
  violetred : IM_D.violetred,
  lightcoral : IM_D.lightcoral,
  hotpink : IM_D.hotpink,
  palevioletred : IM_D.palevioletred,
  lightpink : IM_D.lightpink,
  rosybrown : IM_D.rosybrown,
  pink : IM_D.pink,
  orchid : IM_D.orchid,
  lavenderblush : IM_D.lavenderblush,
  snow : IM_D.snow,
  chocolate : IM_D.chocolate,
  saddlebrown : IM_D.saddlebrown,
  brown : IM_D.brown,
  darkorange : IM_D.darkorange,
  coral : IM_D.coral,
  sienna : IM_D.sienna,
  orange : IM_D.orange,
  salmon : IM_D.salmon,
  peru : IM_D.peru,
  darkgoldenrod : IM_D.darkgoldenrod,
  goldenrod : IM_D.goldenrod,
  sandybrown : IM_D.sandybrown,
  lightsalmon : IM_D.lightsalmon,
  darksalmon : IM_D.darksalmon,
  gold : IM_D.gold,
  yellow : IM_D.yellow,
  olive : IM_D.olive,
  burlywood : IM_D.burlywood,
  tan : IM_D.tan,
  navajowhite : IM_D.navajowhite,
  peachpuff : IM_D.peachpuff,
  khaki : IM_D.khaki,
  darkkhaki : IM_D.darkkhaki,
  moccasin : IM_D.moccasin,
  wheat : IM_D.wheat,
  bisque : IM_D.bisque,
  palegoldenrod : IM_D.palegoldenrod,
  blanchedalmond : IM_D.blanchedalmond,
  mediumgoldenrod : IM_D.mediumgoldenrod,
  papayawhip : IM_D.papayawhip,
  mistyrose : IM_D.mistyrose,
  lemonchiffon : IM_D.lemonchiffon,
  antiquewhite : IM_D.antiquewhite,
  cornsilk : IM_D.cornsilk,
  lightgoldenrodyellow : IM_D.lightgoldenrodyellow,
  oldlace : IM_D.oldlace,
  linen : IM_D.linen,
  lightyellow : IM_D.lightyellow,
  seashell : IM_D.seashell,
  beige : IM_D.beige,
  floralwhite : IM_D.floralwhite,
  ivory : IM_D.ivory,
  green : IM_D.green,
  lawngreen : IM_D.lawngreen,
  chartreuse : IM_D.chartreuse,
  greenyellow : IM_D.greenyellow,
  yellowgreen : IM_D.yellowgreen,
  mediumforestgreen : IM_D.mediumforestgreen,
  olivedrab : IM_D.olivedrab,
  darkolivegreen : IM_D.darkolivegreen,
  darkseagreen : IM_D.darkseagreen,
  lime : IM_D.lime,
  darkgreen : IM_D.darkgreen,
  limegreen : IM_D.limegreen,
  forestgreen : IM_D.forestgreen,
  springgreen : IM_D.springgreen,
  mediumspringgreen : IM_D.mediumspringgreen,
  seagreen : IM_D.seagreen,
  mediumseagreen : IM_D.mediumseagreen,
  aquamarine : IM_D.aquamarine,
  lightgreen : IM_D.lightgreen,
  palegreen : IM_D.palegreen,
  mediumaquamarine : IM_D.mediumaquamarine,
  turquoise : IM_D.turquoise,
  lightseagreen : IM_D.lightseagreen,
  mediumturquoise : IM_D.mediumturquoise,
  honeydew : IM_D.honeydew,
  mintcream : IM_D.mintcream,
  royalblue : IM_D.royalblue,
  dodgerblue : IM_D.dodgerblue,
  deepskyblue : IM_D.deepskyblue,
  cornflowerblue : IM_D.cornflowerblue,
  steelblue : IM_D.steelblue,
  lightskyblue : IM_D.lightskyblue,
  darkturquoise : IM_D.darkturquoise,
  cyan : IM_D.cyan,
  aqua : IM_D.aqua,
  darkcyan : IM_D.darkcyan,
  teal : IM_D.teal,
  skyblue : IM_D.skyblue,
  cadetblue : IM_D.cadetblue,
  darkslategray : IM_D.darkslategray,
  lightslategray : IM_D.lightslategray,
  slategray : IM_D.slategray,
  lightsteelblue : IM_D.lightsteelblue,
  lightblue : IM_D.lightblue,
  powderblue : IM_D.powderblue,
  paleturquoise : IM_D.paleturquoise,
  lightcyan : IM_D.lightcyan,
  aliceblue : IM_D.aliceblue,
  azure : IM_D.azure,
  mediumblue : IM_D.mediumblue,
  darkblue : IM_D.darkblue,
  midnightblue : IM_D.midnightblue,
  navy : IM_D.navy,
  blue : IM_D.blue,
  indigo : IM_D.indigo,
  blueviolet : IM_D.blueviolet,
  mediumslateblue : IM_D.mediumslateblue,
  slateblue : IM_D.slateblue,
  purple : IM_D.purple,
  darkslateblue : IM_D.darkslateblue,
  darkviolet : IM_D.darkviolet,
  darkorchid : IM_D.darkorchid,
  mediumpurple : IM_D.mediumpurple,
  mediumorchid : IM_D.mediumorchid,
  magenta : IM_D.magenta,
  fuchsia : IM_D.fuchsia,
  darkmagenta : IM_D.darkmagenta,
  violet : IM_D.violet,
  plum : IM_D.plum,
  lavender : IM_D.lavender,
  thistle : IM_D.thistle,
  ghostwhite : IM_D.ghostwhite,
  white : IM_D.white,
  whitesmoke : IM_D.whitesmoke,
  gainsboro : IM_D.gainsboro,
  lightgray : IM_D.lightgray,
  silver : IM_D.silver,
  gray : IM_D.gray,
  grey : IM_D.grey,
  darkgray : IM_D.darkgray,
  dimgray : IM_D.dimgray,
  black : IM_D.black,
  outline : IM_D.outline,
  solid : IM_D.solid,
  x-left : IM_D.x-left,
  x-center : IM_D.x-center,
  x-right : IM_D.x-right,
  y-top : IM_D.y-top,
  y-center : IM_D.y-center,
  y-bottom : IM_D.y-bottom,
  pen : IM_D.pen,
  style-dot : IM_D.style-dot,
  style-solid : IM_D.style-solid,
  style-long-dash : IM_D.style-long-dash,
  style-short-dash : IM_D.style-short-dash,
  style-dot-dash : IM_D.style-dot-dash,
  cap-round : IM_D.cap-round,
  cap-projecting : IM_D.cap-projecting,
  cap-butt : IM_D.cap-butt,
  join-bevel : IM_D.join-bevel,
  join-miter : IM_D.join-miter,
  join-round : IM_D.join-round,
  posn : IM_AUX_DATA.posn,
  box : IM_AUX_DATA.box,
  ivl : IM_AUX_DATA.ivl,
  vector-sub : IM_MTX.vector-sub,
  points-bounding-box : IM_MTX.points-bounding-box,
  list-of-points-bounding-box : IM_MTX.list-of-points-bounding-box,
  mtx-center : IM_MTX.mtx-center,
  translate : IM_MTX.translate,
  translate-posn : IM_MTX.translate-posn,
  trans-mtx : IM_MTX.trans-mtx,
  homogeneous-transform : IM_MTX.homogeneous-transform,
  transform-posn : IM_MTX.transform-posn,
  transform-posn-about : IM_MTX.transform-posn-about,
  affine-transform-matrix : IM_MTX.affine-transform-matrix,
  matrix-to-posns : IM_MTX.matrix-to-posns,
  matrices-to-posns : IM_MTX.matrices-to-posns,
  bezier-box : IM_MTX.bezier-box,
  bezier-snap-trans : IM_MTX.bezier-snap-trans,
  cornerbox : IM_MTX.cornerbox,
  bez-corner-box : IM_MTX.bez-corner-box,
  poly-corner-box : IM_MTX.poly-corner-box,
  circle : circle,
  ellipse : ellipse,
  line : line,
  #make-text : make-text,
  #make-text-font : make-text-font,
  triangle : triangle,
  right-triangle : right-triangle,
  isosceles-triangle : isosceles-triangle,
  triangle-sss : triangle-sss,
  triangle-ass : triangle-ass,
  triangle-sas : triangle-sas,
  triangle-ssa : triangle-ssa,
  triangle-aas : triangle-aas,
  triangle-asa : triangle-asa,
  triangle-saa : triangle-saa,
  square : square,
  rectangle : make-rectangle,
  rhombus : rhombus,
  star : star,
  radial-star : radial-star,
  star-sized : star-sized,
  star-polygon : star-polygon,
  regular-polygon : regular-polygon,
  #empty-image : empty-image,
  overlay : overlay,
  overlay-pinhole : overlay-pinhole,
  overlay-align : overlay-align,
  overlay-offset : overlay-offset,
  overlay-align-offset : overlay-align-offset,
  overlay-xy : overlay-xy,
  underlay : underlay,
  underlay-pinhole : underlay-pinhole,
  underlay-align : underlay-align,
  underlay-offset : underlay-offset,
  underlay-align-offset : underlay-align-offset,
  underlay-xy : underlay-xy,
  beside : beside,
  beside-list : beside-list,
  beside-align : beside-align,
  beside-align-list : beside-align-list,
  above : above,
  above-list : above-list,
  above-align : above-align,
  above-align-list : above-align-list,
  empty-scene : empty-scene,
  colored-empty-scene : colored-empty-scene,
  place-image : place-image,
  place-images : place-images,
  place-image-align : place-image-align,
  place-images-align : place-images-align,
  frame : frame,
  add-line : add-line,
  add-curve : add-curve,
  add-line-to-scene : add-line-to-scene,
  add-curve-to-scene : add-curve-to-scene,
  polygon : make-polygon-from-points,
  add-polygon : add-polygon,
  add-polygon-to-scene : add-polygon-to-scene,
  draw-svg : draw-svg,
  draw-debug : draw-debug
} end
# For now, this is commented until
# the Documentation bug is fixed
# provide-types {
#   Image : Image,
#   Color : IM_D.Color,
#   Mode : IM_D.Mode,
#   X-Place : IM_D.X-Place,
#   Y-Place : IM_D.Y-Place
# }
import matrix, vector from matrices
import matrices as M
import xml as XML
import image_datatypes as IM_D
import image_auxiliary_datatypes as IM_AUX_DATA
import image_matrix_helpers as IM_MTX
import Equal, NotEqual from equality

pi = 2 * num-asin(1)

fun to-radians(theta :: Number):
  doc: "Converts the given angle from degrees into radians"
  (theta * pi) * (1 / 180)
end

fun to-degrees(theta :: Number):
  doc: "Converts the given angle from radians into degrees"
  (theta * 180) / pi
end

#########################
# PYRET IMAGE DATATYPES #
#########################

# nonzero-nat
# Predicate to check if the
#   given number is a Natural
#   number greater than 0.
fun nonzero-nat(n :: Number) -> Boolean:
  (0 < n) and num-is-integer(n)
end

matrix2d = lam(m): m.rows == 2 end

### DATA DEFINITIONS

type Color = IM_D.Color
type Mode = IM_D.Mode
type X-Place = IM_D.X-Place
type Y-Place = IM_D.Y-Place

rgba-color = IM_D.rgba-color
rgb-color = IM_D.rgb-color
pen = IM_D.pen
style-dot = IM_D.style-dot
style-solid = IM_D.style-solid
style-long-dash = IM_D.style-long-dash
style-short-dash = IM_D.style-short-dash
style-dot-dash = IM_D.style-dot-dash
cap-round = IM_D.cap-round
cap-projecting = IM_D.cap-projecting
cap-butt = IM_D.cap-butt
join-bevel = IM_D.join-bevel
join-miter = IM_D.join-miter
join-round = IM_D.join-round
orangered = IM_D.orangered
tomato = IM_D.tomato
darkred = IM_D.darkred
red = IM_D.red
firebrick = IM_D.firebrick
crimson = IM_D.crimson
deeppink = IM_D.deeppink
maroon = IM_D.maroon
indianred = IM_D.indianred
mediumvioletred = IM_D.mediumvioletred
violetred = IM_D.violetred
lightcoral = IM_D.lightcoral
hotpink = IM_D.hotpink
palevioletred = IM_D.palevioletred
lightpink = IM_D.lightpink
rosybrown = IM_D.rosybrown
pink = IM_D.pink
orchid = IM_D.orchid
lavenderblush = IM_D.lavenderblush
snow = IM_D.snow
chocolate = IM_D.chocolate
saddlebrown = IM_D.saddlebrown
brown = IM_D.brown
darkorange = IM_D.darkorange
coral = IM_D.coral
sienna = IM_D.sienna
orange = IM_D.orange
salmon = IM_D.salmon
peru = IM_D.peru
darkgoldenrod = IM_D.darkgoldenrod
goldenrod = IM_D.goldenrod
sandybrown = IM_D.sandybrown
lightsalmon = IM_D.lightsalmon
darksalmon = IM_D.darksalmon
gold = IM_D.gold
yellow = IM_D.yellow
olive = IM_D.olive
burlywood = IM_D.burlywood
tan = IM_D.tan
navajowhite = IM_D.navajowhite
peachpuff = IM_D.peachpuff
khaki = IM_D.khaki
darkkhaki = IM_D.darkkhaki
moccasin = IM_D.moccasin
wheat = IM_D.wheat
bisque = IM_D.bisque
palegoldenrod = IM_D.palegoldenrod
blanchedalmond = IM_D.blanchedalmond
mediumgoldenrod = IM_D.mediumgoldenrod
papayawhip = IM_D.papayawhip
mistyrose = IM_D.mistyrose
lemonchiffon = IM_D.lemonchiffon
antiquewhite = IM_D.antiquewhite
cornsilk = IM_D.cornsilk
lightgoldenrodyellow = IM_D.lightgoldenrodyellow
oldlace = IM_D.oldlace
linen = IM_D.linen
lightyellow = IM_D.lightyellow
seashell = IM_D.seashell
beige = IM_D.beige
floralwhite = IM_D.floralwhite
ivory = IM_D.ivory
green = IM_D.green
lawngreen = IM_D.lawngreen
chartreuse = IM_D.chartreuse
greenyellow = IM_D.greenyellow
yellowgreen = IM_D.yellowgreen
mediumforestgreen = IM_D.mediumforestgreen
olivedrab = IM_D.olivedrab
darkolivegreen = IM_D.darkolivegreen
darkseagreen = IM_D.darkseagreen
lime = IM_D.lime
darkgreen = IM_D.darkgreen
limegreen = IM_D.limegreen
forestgreen = IM_D.forestgreen
springgreen = IM_D.springgreen
mediumspringgreen = IM_D.mediumspringgreen
seagreen = IM_D.seagreen
mediumseagreen = IM_D.mediumseagreen
aquamarine = IM_D.aquamarine
lightgreen = IM_D.lightgreen
palegreen = IM_D.palegreen
mediumaquamarine = IM_D.mediumaquamarine
turquoise = IM_D.turquoise
lightseagreen = IM_D.lightseagreen
mediumturquoise = IM_D.mediumturquoise
honeydew = IM_D.honeydew
mintcream = IM_D.mintcream
royalblue = IM_D.royalblue
dodgerblue = IM_D.dodgerblue
deepskyblue = IM_D.deepskyblue
cornflowerblue = IM_D.cornflowerblue
steelblue = IM_D.steelblue
lightskyblue = IM_D.lightskyblue
darkturquoise = IM_D.darkturquoise
cyan = IM_D.cyan
aqua = IM_D.aqua
darkcyan = IM_D.darkcyan
teal = IM_D.teal
skyblue = IM_D.skyblue
cadetblue = IM_D.cadetblue
darkslategray = IM_D.darkslategray
lightslategray = IM_D.lightslategray
slategray = IM_D.slategray
lightsteelblue = IM_D.lightsteelblue
lightblue = IM_D.lightblue
powderblue = IM_D.powderblue
paleturquoise = IM_D.paleturquoise
lightcyan = IM_D.lightcyan
aliceblue = IM_D.aliceblue
azure = IM_D.azure
mediumblue = IM_D.mediumblue
darkblue = IM_D.darkblue
midnightblue = IM_D.midnightblue
navy = IM_D.navy
blue = IM_D.blue
indigo = IM_D.indigo
blueviolet = IM_D.blueviolet
mediumslateblue = IM_D.mediumslateblue
slateblue = IM_D.slateblue
purple = IM_D.purple
darkslateblue = IM_D.darkslateblue
darkviolet = IM_D.darkviolet
darkorchid = IM_D.darkorchid
mediumpurple = IM_D.mediumpurple
mediumorchid = IM_D.mediumorchid
magenta = IM_D.magenta
fuchsia = IM_D.fuchsia
darkmagenta = IM_D.darkmagenta
violet = IM_D.violet
plum = IM_D.plum
lavender = IM_D.lavender
thistle = IM_D.thistle
ghostwhite = IM_D.ghostwhite
white = IM_D.white
whitesmoke = IM_D.whitesmoke
gainsboro = IM_D.gainsboro
lightgray = IM_D.lightgray
silver = IM_D.silver
gray = IM_D.gray
grey = IM_D.grey
darkgray = IM_D.darkgray
dimgray = IM_D.dimgray
black = IM_D.black
outline = IM_D.outline
solid = IM_D.solid
x-left = IM_D.x-left
x-center = IM_D.x-center
x-right = IM_D.x-right
y-top = IM_D.y-top
y-center = IM_D.y-center
y-bottom = IM_D.y-bottom

type Position = IM_AUX_DATA.Position
type Box = IM_AUX_DATA.Box
type Interval = IM_AUX_DATA.Interval

posn = IM_AUX_DATA.posn
explicit-posn = IM_AUX_DATA.explicit-posn
is-explicit-posn = IM_AUX_DATA.is-explicit-posn
box = IM_AUX_DATA.box
ivl = IM_AUX_DATA.ivl

vector-sub = IM_MTX.vector-sub
points-bounding-box = IM_MTX.points-bounding-box
list-of-points-bounding-box = IM_MTX.list-of-points-bounding-box
mtx-center = IM_MTX.mtx-center
translate = IM_MTX.translate
translate-posn = IM_MTX.translate-posn
trans-mtx = IM_MTX.trans-mtx
homogeneous-transform = IM_MTX.homogeneous-transform
transform-posn = IM_MTX.transform-posn
transform-posn-about = IM_MTX.transform-posn-about
affine-transform-matrix = IM_MTX.affine-transform-matrix
matrix-to-posns = IM_MTX.matrix-to-posns
matrices-to-posns = IM_MTX.matrices-to-posns
bezier-box = IM_MTX.bezier-box
bezier-snap-trans = IM_MTX.bezier-snap-trans

type CornerBox = IM_MTX.CornerBox
cornerbox = IM_MTX.cornerbox
bez-corner-box = IM_MTX.bez-corner-box
poly-corner-box = IM_MTX.poly-corner-box

fun reorder-step(lst :: List, step :: Number%(nonzero-nat)):
  doc: "Reorders the given list using the given step size"
  len = lst.length()
  new-idx = lam(i): num-modulo(i * step, len) end
  var ret-lst = empty
  for each(i from range(1, len + 1).reverse()):
    ret-lst := link(lst.get(new-idx(len - i)), ret-lst)
  end
  ret-lst
end

# Transformation Matrices Definitions

fun rotation-matrix(theta-deg :: Number) -> M.Matrix:
  doc: "Returns a rotation matrix for the given counterclockwise angle"
  theta = -1 * to-radians(theta-deg)
  [matrix(2,2): num-cos(theta), (-1 * num-sin(theta)),
    num-sin(theta), num-cos(theta)]
end

fun scale-xy-matrix(xk :: Number, yk :: Number) -> M.Matrix:
  doc: "Returns an xy-scaling matrix for the given scales"
  [matrix(2,2): xk, 0, 0, yk]
end

fun scale-x-matrix(k :: Number) -> M.Matrix:
  doc: "Returns an x-scaling matrix for the given scale"
  scale-xy-matrix(k, 1)
end

fun scale-y-matrix(k :: Number) -> M.Matrix:
  doc: "Returns a y-scaling matrix for the given scale"
  scale-xy-matrix(1, k)
end

fun scale-matrix(k :: Number) -> M.Matrix:
  doc: "Returns a scaling matrix for the given amount"
  scale-xy-matrix(k, k)
end


flip-horiz-matrix = [matrix(2,2): -1, 0, 0, 1]

flip-vert-matrix = [matrix(2,2): 1, 0, 0, -1]

#############################
## Object System definitions#
#############################

newtype Image as ImageT

data PrivateKey:
  | private-key(id :: Number)
end
PKEY = private-key(num-random(10))
is-valid-key = identical(PKEY, _)

data RefObject:
  | ref-object(ref self :: Object)
    with:
    get-self(rself) -> Object:
      ref-get(rself.self)
    end,
    get-public(rself) -> Object:
      rself.get-self()._public.get-self()
    end,
    custom-match(rself, match-dict):
      # FIXME: As it is, this thunk won't get called; instead,
      #        a "field not found" error is raised.
      rself.get-self()._match(match-dict, lam(): raise('No matching case branches') end)
    end,
    finalize(rself) -> Object:
      rself.get-public()
    end
end

fun extend(o :: RefObject, new-self :: Object) -> RefObject:
  o!{self : new-self}
  o
end

fun extend-public-only(o :: RefObject, new-public :: Object) -> RefObject:
  o.get-self()._public!{ self : new-public }
  o
end

fun extend-with-public(o :: RefObject, new-self :: Object, new-pubs :: Object) -> RefObject:
  extend-public-only(extend(o, new-self), new-pubs)
end

fun finalize-image(o :: RefObject) -> Image:
  ImageT.brand(o.finalize())
end

fun custom-match(o :: Object, dct :: Object):
  o.intref(PKEY).get-self()._match(dct, lam(): raise('No matching case branches') end)
end

fun empty-object() -> RefObject:
  ref-object({ _public : ref-object({}), _match : lam(d, e): raise('_match not implemented') end})
end

# Datatype constructors (for reference in datatype code)
var constructors = {}

# For convenience
fun no-arg-caller(o :: Object, impl :: (Object -> Any)):
  lam(): impl(o.get-self()) end
end

fun snap-row-trans(img :: List<List<Number>>) -> M.Vector:
  doc: "Returns the vector needed to snap the given list of points to the bounds of the first quadrant"
  min-x = img.first.map(num-exact).sort().first
  min-y = img.get(1).map(num-exact).sort().first
  trans-x = if (min-x < 0):
    num-abs(min-x)
  else:
    -1 * min-x
  end
  trans-y = if (min-y < 0):
    num-abs(min-y)
  else:
    -1 * min-y
  end
  [vector: trans-x, trans-y]
end

# Needed inside of abstract-image, so placing here
# with polygon-maker parameter subverts scoping problems
fun rectangle(polygon-maker,
              width  :: Number%(num-is-positive),
              height :: Number%(num-is-positive),
              mode   :: Mode,
              color  :: Color) :
  polygon-maker([matrix(2,4):  0, 0, width, width,
      0, height, height, 0], mode, color, posn((width / 2), (height / 2))).intref(PKEY).get-self().snap-axes()
end

fun calc-compound-vector(top-img, bot-img, bot-center, at):
  basis = bot-img.coord-zero()
  true-at = posn(at.x + basis.x, at.y + basis.y)
  tpin = top-img.get-center()
  [list: true-at.x - tpin.x, true-at.y - tpin.y]
end

# Base Image Class. Most public methods written here.
fun abstract-image() -> RefObject:
  doc: "Creates the base object for Image types"
  ret = empty-object()
  fun flip-horizontal-impl(self):
    self.affine-transform(flip-horiz-matrix).intref(PKEY).get-self().snap-axes()
  end
  flip-hotizontal-caller = no-arg-caller(ret, flip-horizontal-impl)

  fun flip-vertical-impl(self):
    self.affine-transform(flip-vert-matrix).intref(PKEY).get-self().snap-axes()
  end
  flip-vertical-caller = no-arg-caller(ret, flip-vertical-impl)

  fun scale-x-impl(self, k :: Number):
    self.affine-transform(scale-x-matrix(k)).intref(PKEY).get-self().snap-axes()
  end
  scale-x-caller = scale-x-impl(ret.get-self(), _)

  fun scale-y-impl(self, k :: Number):
    self.affine-transform(scale-y-matrix(k)).intref(PKEY).get-self().snap-axes()
  end
  scale-y-caller = scale-y-impl(ret.get-self(), _)

  fun scale-xy-impl(self, x-factor :: Number, y-factor :: Number):
    self.affine-transform(scale-xy-matrix(x-factor, y-factor)).intref(PKEY).get-self().snap-axes()
  end
  scale-xy-caller = scale-xy-impl(ret.get-self(), _, _)

  fun scale-impl(self, factor :: Number):
    self.affine-transform(scale-matrix(factor)).intref(PKEY).get-self(
      ).snap-axes().intref(PKEY).get-self().scale-pen(factor)
  end
  scale-caller = scale-impl(ret.get-self(), _)

  fun rotate-impl(self, angle :: Number):
    self.affine-transform(rotation-matrix(angle)).intref(PKEY).get-self().snap-axes()
  end
  rotate-caller = rotate-impl(ret.get-self(), _)

  fun crop-impl(self, x :: Number, y :: Number, width :: Number, height :: Number):
    self-bb = self.get-box()
    at = posn((self-bb.width / 2) - x, (self-bb.height / 2) - y)
    clip = rectangle(constructors.polygon, width, height, outline, black)
    pin = self.make-pinhole(width / 2, height / 2)
    final-self = finalize-image(self.intref(PKEY))
    constructors.clipped-image(constructors.compound-image(final-self, at, clip, pin), true)
  end
  crop-caller = crop-impl(ret.get-self(), _, _, _, _)

  fun crop-align-impl(self, x-place :: X-Place, y-place :: Y-Place, width :: Number, height :: Number):
    self-bb = self.get-box()
    at = posn(cases(X-Place) x-place:
        | x-left => (self-bb.width / 2)
        | x-center => (width / 2)
        | x-right => width - (self-bb.width / 2)
      end, cases(Y-Place) y-place:
        | y-top => (self-bb.height / 2)
        | y-center => (height / 2)
        | y-bottom => height - (self-bb.height / 2)
      end)
    clip = rectangle(constructors.polygon, width, height, outline, black)
    pin = self.make-pinhole(width / 2, height / 2)
    final-self = finalize-image(self.intref(PKEY))
    constructors.clipped-image(constructors.compound-image(final-self, at, clip, pin), true)
  end
  crop-align-caller = crop-align-impl(ret.get-self(), _, _, _, _)

  fun width-impl(self) -> Number:
    self.get-box().width
  end
  width-caller = no-arg-caller(ret, width-impl)

  fun height-impl(self) -> Number:
    self.get-box().height
  end
  height-caller = no-arg-caller(ret, height-impl)

  fun coord-zero-impl(self) -> Position:
    self.cornerbox().top-left
  end
  coord-zero-caller = no-arg-caller(ret, coord-zero-impl)

  fun pinhole-x-impl(self):
    pin = self.get-pinhole()
    if is-explicit-posn(pin):
      pin.x
    else:
      false
    end
  end
  pinhole-x-caller = no-arg-caller(ret, pinhole-x-impl)

  fun pinhole-y-impl(self):
    pin = self.get-pinhole()
    if is-explicit-posn(pin):
      pin.y
    else:
      false
    end
  end
  pinhole-y-caller = no-arg-caller(ret, pinhole-y-impl)

  fun center-pinhole-impl(self):
    center = self.get-center()
    self.put-pinhole(center.x, center.y)
  end
  center-pinhole-caller = no-arg-caller(ret, center-pinhole-impl)

  fun make-pinhole-impl(self, x :: Number, y :: Number) -> Position:
    if is-explicit-posn(self.get-pinhole()):
      explicit-posn(x, y)
    else:
      posn(x, y)
    end
  end
  make-pinhole-caller = make-pinhole-impl(ret.get-self(), _, _)

  # This default implementation is likely inefficient and should be overridden by subclasses
  fun affine-transform-about-impl(self, transformation :: M.Matrix%(matrix2d), abt :: Position) -> Image:
    move-out = [vector: (-1 * abt.x), (-1 * abt.y)]
    move-back = [vector: abt.x, abt.y]
    self.translate(move-out).intref(PKEY).get-self().transform(
      transformation).intref(PKEY).get-self().translate(move-back)
  end
  affine-transform-about-caller = affine-transform-about-impl(ret.get-self(), _, _, _)

  fun affine-transform-impl(self, transformation :: M.Matrix%(matrix2d)) -> Image:
    self.affine-transform-about(transformation, self.get-center())
  end
  affine-transform-caller = affine-transform-impl(ret.get-self(), _)

  fun snap-axes-impl(self) -> Image:
    self.translate(self.snap-vec())
  end
  snap-axes-caller = no-arg-caller(ret, snap-axes-impl)

  fun svg-size-impl(self):
    self.cornerbox().to-box()
  end
  svg-size-caller = no-arg-caller(ret, svg-size-impl)

  # Is this *required*? Probably not. On the other hand,
  # it simplifies a lot of code at the cost of 
  # not-quite-but-almost-perfect data hiding.
  fun intref(key :: PrivateKey):
    doc: "De-finalizes this image, provided that the provided key is valid"
    # The key is neither exported nor stored anywhere but PKEY at the top-level,
    # so it seems safe to assume that only code inside of this file can
    # provide the correct key.
    when not(is-valid-key(key)):
      raise('Invalid key provided: ' + torepr(key))
    end
    ret
  end

  fun image-type-impl(self) -> String:
    "None"
  end
  image-type-caller = no-arg-caller(ret, image-type-impl)

  new-pubs = ret.get-public().{
    flip-horizontal : flip-hotizontal-caller,
    flip-vertical : flip-vertical-caller,
    scale-x : scale-x-caller,
    scale-y : scale-y-caller,
    scale-xy : scale-xy-caller,
    scale : scale-caller,
    rotate : rotate-caller,
    crop : crop-caller,
    crop-align : crop-align-caller,
    width : width-caller,
    height : height-caller,
    pinhole-x : pinhole-x-caller,
    pinhole-y : pinhole-y-caller,
    center-pinhole : center-pinhole-caller,
    intref : intref
  }

  extended-self = ret.get-self().{
    flip-horizontal : flip-hotizontal-caller,
    flip-vertical : flip-vertical-caller,
    scale-x : scale-x-caller,
    scale-y : scale-y-caller,
    scale-xy : scale-xy-caller,
    scale : scale-caller,
    rotate : rotate-caller,
    crop : crop-caller,
    crop-align : crop-align-caller,
    width : width-caller,
    height : height-caller,
    pinhole-x : pinhole-x-caller,
    pinhole-y : pinhole-y-caller,
    center-pinhole : center-pinhole-caller,
    coord-zero : coord-zero-caller,
    make-pinhole : make-pinhole-caller,
    affine-transform-about : affine-transform-about-caller,
    affine-transform : affine-transform-caller,
    snap-axes : snap-axes-caller,
    svg-size : svg-size-caller,
    image-type : image-type-caller,
    intref : intref
  }

  extend-with-public(ret, extended-self, new-pubs)
end

fun abstract-simple-shape(mtrix :: M.Matrix, mode :: Mode, color :: Color, pinhole :: Position, 
                          constructor, cornerbox-calc, snap-calc):
  _super = abstract-image()
  matrix-as-lists = mtrix.to-lists()
  #print('matrix-as-lists: ' + torepr(matrix-as-lists))
  shadow cornerbox = cornerbox-calc(matrix-as-lists)
  shadow center = cornerbox.get-center()
  snap-vector = snap-calc(matrix-as-lists)

  fun to-matrix-impl(self) -> M.Matrix:
    mtrix
  end
  to-matrix-caller = no-arg-caller(_super, to-matrix-impl)

  fun get-box-impl(self) -> Box:
    cornerbox.to-box()
  end
  get-box-caller = no-arg-caller(_super, get-box-impl)

  fun translate-impl(self, v :: M.Vector) -> Image:
    constructor(translate(mtrix, v), mode, color, translate-posn(pinhole, v))
  end
  translate-caller = translate-impl(_super.get-self(), _)

  fun transform-impl(self, mtx :: M.Matrix) -> Image:
    constructor(homogeneous-transform(mtx, mtrix), mode, color, transform-posn(mtx, pinhole))
  end
  transform-caller = transform-impl(_super.get-self(), _)

  # @Override
  fun affine-transform-about-impl(self, transformation :: M.Matrix%(matrix2d), abt :: Position) -> Image:
    # Avoid creating three images and just do the full transformation at once
    move-out = [vector: (-1 * abt.x), (-1 * abt.y)]
    move-back = [vector: abt.x, abt.y]
    shadow trans-mtx = translate(homogeneous-transform(transformation, translate(mtrix, move-out)), move-back)
    trans-pin = translate-posn(transform-posn(transformation, translate-posn(pinhole, move-out)), move-back)
    constructor(trans-mtx, mode, color, trans-pin)
  end
  affine-transform-about-caller = affine-transform-about-impl(_super.get-self(), _, _)

  fun snap-vec-impl(self):
    snap-vector
  end
  snap-vec-caller = no-arg-caller(_super, snap-vec-impl)

  fun new-color-impl(self, k :: Color) -> Image:
    constructor(mtrix, mode, k, pinhole)
  end
  new-color-caller = new-color-impl(_super.get-self(), _)

  fun scale-pen-impl(self, k :: Number%(num-is-non-negative)) -> Image:
    constructor(mtrix, mode, color.scale(k), pinhole)
  end
  scale-pen-caller = scale-pen-impl(_super.get-self(), _)

  fun put-pinhole-impl(self, x :: Number, y :: Number) -> Image:
    constructor(mtrix, mode, color, explicit-posn(x, y))
  end
  put-pinhole-caller = put-pinhole-impl(_super, _, _)

  fun clear-pinhole-impl(self) -> Image:
    constructor(mtrix, mode, color, center)
  end
  clear-pinhole-caller = no-arg-caller(_super, clear-pinhole-impl)

  fun cornerbox-impl(self) -> CornerBox:
    cornerbox
  end
  cornerbox-caller = no-arg-caller(_super, cornerbox-impl)

  fun get-center-impl(self) -> Position:
    center
  end
  get-center-caller = no-arg-caller(_super, get-center-impl)

  fun get-pinhole-impl(self) -> Position:
    pinhole
  end
  get-pinhole-caller = no-arg-caller(_super, get-pinhole-impl)

  fun get-mode-impl(self) -> Mode:
    mode
  end
  get-mode-caller = no-arg-caller(_super, get-mode-impl)

  new-pubs = _super.get-public().{
    put-pinhole : put-pinhole-caller,
    clear-pinhole : clear-pinhole-caller
  }

  extended-self = _super.get-self().{
    to-matrix : to-matrix-caller,
    get-box : get-box-caller,
    translate : translate-caller,
    transform : transform-caller,
    affine-transform-about : affine-transform-about-caller,
    snap-vec : snap-vec-caller,
    new-color : new-color-caller,
    scale-pen : scale-pen-caller,
    put-pinhole : put-pinhole-caller,
    clear-pinhole : clear-pinhole-caller,
    cornerbox : cornerbox-caller,
    get-center : get-center-caller,
    get-pinhole : get-pinhole-caller,
    get-mode : get-mode-caller,
    matrix : mtrix,
    mode : mode,
    color : color,
    pinhole : pinhole
  }

  extend-with-public(_super, extended-self, new-pubs)
end

fun polygon(mtrix :: M.Matrix, mode :: Mode, color :: Color, pinhole :: Position) -> Image:
  _super = abstract-simple-shape(mtrix, mode, color, pinhole, polygon, poly-corner-box, snap-row-trans)

  fun image-type-impl(self) -> String:
    "Polygon"
  end
  image-type-caller = no-arg-caller(_super, image-type-impl)

  fun polygon-match(dict, err-thunk):
    dict.polygon(_super.get-self(), mtrix, mode, color, pinhole)
  end
  extended-self = _super.get-self().{_match : polygon-match, image-type : image-type-caller}
  ret = extend(_super, extended-self)
  finalize-image(ret)
end
constructors := constructors.{polygon : polygon}

fun bezier-shape(mtrix :: M.Matrix, mode :: Mode, color :: Color, pinhole :: Position) -> Image:
  collapse-first = lam(f): lam(l): f(map2(posn, l.first, l.rest.first)) end end
  _super = abstract-simple-shape(mtrix, mode, color, pinhole, bezier-shape, 
    collapse-first(bez-corner-box), collapse-first(bezier-snap-trans))

  fun image-type-impl(self) -> String:
    "Bezier"
  end
  image-type-caller = no-arg-caller(_super, image-type-impl)

  fun bezier-shape-match(dict, err-thunk):
    dict.bezier-shape(_super.get-self(), mtrix, mode, color, pinhole)
  end
  extended-self = _super.get-self().{_match : bezier-shape-match, image-type : image-type-caller}
  ret = extend(_super, extended-self)
  finalize-image(ret)
end
constructors := constructors.{bezier-shape : bezier-shape}

fun compound-image(top :: Image, at :: Position, bottom :: Image, pinhole :: Position) -> Image:
  _super = abstract-image()
  # Expose private top and bottom methods
  # (they are intended to be, in Java terminology,
  #  package-private)
  tprot = top.intref(PKEY).get-self()
  bprot = bottom.intref(PKEY).get-self()

  # Put these inside of functions to avoid namespace pollution
  fun calculate-cornerbox():
    dvec = calc-compound-vector(tprot, bprot, bprot.get-center(), at)
    trans-topx-p = dvec.first >= 0
    trans-topy-p = dvec.rest.first >= 0
    dtx = if trans-topx-p: dvec.first else: 0 end
    dty = if trans-topy-p: dvec.rest.first else: 0 end
    dbx = if trans-topx-p: 0 else: -1 * dvec.first end
    dby = if trans-topy-p: 0 else: -1 * dvec.rest.first end
    trans-box = tprot.cornerbox().translate(dtx, dty)
    trans-box.join(bprot.cornerbox().translate(dbx, dby))
  end
  fun calculate-snap-vec():
    t-trans = tprot.snap-vec()
    b-trans = bprot.snap-vec()
    [vector: num-max(t-trans.first, b-trans.first), num-max(t-trans.rest.first, b-trans.rest.first)]
  end

  shadow cornerbox = calculate-cornerbox()
  center = cornerbox.get-center()
  shadow box = cornerbox.to-box()
  snapvec = calculate-snap-vec()

  fun get-box-impl(self):
    box
  end
  get-box-caller = no-arg-caller(_super, get-box-impl)

  fun translate-impl(self, v :: M.Vector) -> Image:
    compound-image(tprot.translate(v), at, bprot.translate(v), translate-posn(pinhole, v))
  end
  translate-caller = translate-impl(_super.get-self(), _)

  # @Override
  fun affine-transform-about-impl(self, transformation :: M.Matrix%(matrix2d), abt :: Position) -> Image:
    self.translate([vector: -1 * abt.x, -1 * abt.y]).intref(PKEY).get-self().affine-transform(
      transformation).intref(PKEY).get-self().translate([vector: abt.x, abt.y])
  end
  affine-transform-about-caller = affine-transform-about-impl(_super.get-self(), _, _)

  # @Override
  fun affine-transform-impl(self, transformation :: M.Matrix%(matrix2d)) -> Image:
    bottom-center = bprot.get-center()
    ti = tprot.affine-transform-about(transformation, center).intref(PKEY).get-self()
    bi = bprot.affine-transform-about(transformation, center).intref(PKEY).get-self()
    ti-snap = ti.snap-axes()
    bi-snap = bi.snap-axes()
    ti-snapref = ti-snap.intref(PKEY).get-self()
    bi-snapref = bi-snap.intref(PKEY).get-self()
    bottom-zero = bprot.coord-zero()
    true-at = posn(bottom-zero.x + at.x, bottom-zero.y + at.y)
    trans-at = transform-posn-about(transformation, true-at, center)
    bi-zero = bi.coord-zero()
    new-at = posn(trans-at.x - bi-zero.x, trans-at.y - bi-zero.y)
    ti-vec = ti.snap-vec()
    bi-vec = bi.snap-vec()
    offset = posn(pinhole.x - center.x, pinhole.y - center.y)
    trans-off = transform-posn(transformation, offset)
    dvec = calc-compound-vector(ti-snapref, bi-snapref, bi-snapref.get-center(), new-at)
    trans-topx-p = dvec.first >= 0
    trans-topy-p = dvec.rest.first >= 0
    dtx = if trans-topx-p: dvec.first else: 0 end
    dty = if trans-topy-p: dvec.rest.first else: 0 end
    dbx = if trans-topx-p: 0 else: -1 * dvec.first end
    dby = if trans-topy-p: 0 else: -1 * dvec.rest.first end
    top-trans-box = ti-snapref.cornerbox().translate(dtx, dty)
    transformed-center = top-trans-box.join(bi-snapref.cornerbox().translate(dbx, dby)).get-center()
    new-pin = self.make-pinhole(trans-off.x + transformed-center.x, trans-off.y + transformed-center.y)
    compound-image(ti-snap, new-at, bi-snap, new-pin)
  end
  affine-transform-caller = affine-transform-impl(_super.get-self(), _)

  fun snap-vec-impl(self):
    snapvec
  end
  snap-vec-caller = no-arg-caller(_super, snap-vec-impl)

  fun new-color-impl(self, k :: Color) -> Image:
    compound-image(tprot.new-color(k), at, bprot.new-color(k), pinhole)
  end
  new-color-caller = new-color-impl(_super.get-self(), _)

  fun scale-pen-impl(self, k :: Number%(num-is-non-negative)) -> Image:
    compound-image(tprot.scale-pen(k), at, bprot.scale-pen(k), pinhole)
  end
  scale-pen-caller = scale-pen-impl(_super.get-self(), _)

  fun put-pinhole-impl(self, x :: Number, y :: Number) -> Image:
    compound-image(top, at, bottom, explicit-posn(x, y))
  end
  put-pinhole-caller = put-pinhole-impl(_super.get-self(), _, _)

  fun clear-pinhole-impl(self) -> Image:
    compound-image(top, at, bottom, center)
  end
  clear-pinhole-caller = no-arg-caller(_super, clear-pinhole-impl)

  fun cornerbox-impl(self) -> CornerBox:
    cornerbox
  end
  cornerbox-caller = no-arg-caller(_super, cornerbox-impl)

  fun get-center-impl(self) -> Position:
    center
  end
  get-center-caller = no-arg-caller(_super, get-center-impl)

  fun get-pinhole-impl(self) -> Position:
    pinhole
  end
  get-pinhole-caller = no-arg-caller(_super, get-pinhole-impl)

  fun compound-image-match(dict, err-thunk):
    dict.compound-image(_super.get-self(), top, at, bottom, pinhole)
  end

  fun image-type-impl(self) -> String:
    "Compound"
  end
  image-type-caller = no-arg-caller(_super, image-type-impl)

  new-pubs = _super.get-public().{
    put-pinhole : put-pinhole-caller,
    clear-pinhole : clear-pinhole-caller
  }

  extended-self = _super.get-self().{
    get-box : get-box-caller,
    translate : translate-caller,
    affine-transform-about : affine-transform-about-caller,
    affine-transform : affine-transform-caller,
    snap-vec : snap-vec-caller,
    new-color : new-color-caller,
    scale-pen : scale-pen-caller,
    put-pinhole : put-pinhole-caller,
    clear-pinhole : clear-pinhole-caller,
    cornerbox : cornerbox-caller,
    get-center : get-center-caller,
    get-pinhole : get-pinhole-caller,
    _match : compound-image-match,
    image-type : image-type-caller,
    top : top,
    at : at,
    bottom : bottom,
    pinhole : pinhole
  }

  ret = extend-with-public(_super, extended-self, new-pubs)
  finalize-image(ret)
end
constructors := constructors.{compound-image : compound-image}

fun clipped-image(pair :: Image, hidden-mask :: Boolean) -> Image:
  _super = abstract-image()
  pprot = pair.intref(PKEY).get-self()
  pair-bottom = pprot.bottom.intref(PKEY).get-self()

  
  shadow cornerbox = pair-bottom.cornerbox()
  center = cornerbox.get-center()
  this-box = cornerbox.to-box()
  snapvec = pprot.snap-vec()

  fun get-box-impl(self):
    this-box
  end
  get-box-caller = no-arg-caller(_super, get-box-impl)

  fun translate-impl(self, v :: M.Vector) -> Image:
    clipped-image(pprot.translate(v), hidden-mask)
  end
  translate-caller = translate-impl(_super.get-self(), _)

  # @Override
  fun affine-transform-about-impl(self, transformation :: M.Matrix%(matrix2d), abt :: Position) -> Image:
    clipped-image(pprot.affine-transform-about(transformation, abt), hidden-mask)
  end
  affine-transform-about-caller = affine-transform-about-impl(_super.get-self(), _, _)

  fun snap-vec-impl(self):
    snapvec
  end
  snap-vec-caller = no-arg-caller(_super, snap-vec-impl)

  fun new-color-impl(self, k :: Color) -> Image:
    clipped-image(pprot.new-color(k), hidden-mask)
  end
  new-color-caller = new-color-impl(_super.get-self(), _)

  fun scale-pen-impl(self, k :: Number%(num-is-non-negative)) -> Image:
    clipped-image(pprot.scale-pen(k), hidden-mask)
  end
  scale-pen-caller = scale-pen-impl(_super.get-self(), _)

  fun put-pinhole-impl(self, x :: Number, y :: Number) -> Image:
    clipped-image(pprot.put-pinhole(x, y), hidden-mask)
  end
  put-pinhole-caller = put-pinhole-impl(_super.get-self(), _, _)

  fun clear-pinhole-impl(self) -> Image:
    new-ci = compound-image(pprot.top, pprot.at, pprot.bot, pair-bottom.get-center())
    clipped-image(new-ci, hidden-mask)
  end
  clear-pinhole-caller = no-arg-caller(_super, clear-pinhole-impl)

  fun cornerbox-impl(self) -> CornerBox:
    cornerbox
  end
  cornerbox-caller = no-arg-caller(_super, cornerbox-impl)

  fun get-center-impl(self) -> Position:
    center
  end
  get-center-caller = no-arg-caller(_super, get-center-impl)

  fun get-pinhole-impl(self) -> Position:
    pprot.pinhole
  end
  get-pinhole-caller = no-arg-caller(_super, get-pinhole-impl)

  fun clipped-image-match(dict, err-thunk):
    dict.clipped-image(_super.get-self(), pair, hidden-mask)
  end

  fun image-type-impl(self) -> String:
    "Clipped"
  end
  image-type-caller = no-arg-caller(_super, image-type-impl)

  new-pubs = _super.get-public().{
    put-pinhole : put-pinhole-caller,
    clear-pinhole : clear-pinhole-caller
  }

  extended-self = _super.get-self().{
    get-box : get-box-caller,
    translate : translate-caller,
    affine-transform-about : affine-transform-about-caller,
    snap-vec : snap-vec-caller,
    new-color : new-color-caller,
    scale-pen : scale-pen-caller,
    put-pinhole : put-pinhole-caller,
    clear-pinhole : clear-pinhole-caller,
    cornerbox : cornerbox-caller,
    get-center : get-center-caller,
    get-pinhole : get-pinhole-caller,
    _match : clipped-image-match,
    image-type : image-type-caller,
    pair : pair,
    hidden-mask : hidden-mask
  }

  ret = extend-with-public(_super, extended-self, new-pubs)
  finalize-image(ret)
end
constructors := constructors.{clipped-image : clipped-image}

#####################
## IMAGE CONSTRUCTORS
#####################

fun circle(radius :: Number, mode :: Mode, color :: Color):
  circ-const = 4/3 * (num-sqrt(2) - 1)
  r = radius
  rc = r * circ-const
  cx = radius
  cy = radius
  arc1 = [matrix(2,4): 0, rc, r, r,
    (-1 * r), (-1 * r), (-1 * rc), 0]
  arc2 = [matrix(2,3):  r, rc, 0,
    rc, r, r]
  arc3 = [matrix(2,3):  (-1 * rc), (-1 * r), (-1 * r),
    r, rc, 0]
  arc4 = [matrix(2,3):  (-1 * r), (-1 * rc), 0,
    (-1 * rc), (-1 * r), (-1 * r)]
  
  mtx = translate(arc1.augment(arc2).augment(arc3).augment(arc4),[vector: cx, cy])
  bezier-shape(mtx, mode, color, posn(radius, radius)).intref(PKEY).get-self().snap-axes()
end

fun ellipse(width  :: Number%(num-is-positive),
    height :: Number%(num-is-positive),
    mode   :: Mode,
    color  :: Color) :
  circ-const = 4/3 * (num-sqrt(2) - 1)
  rx = width / 2
  ry = height / 2
  rxc = rx * circ-const
  ryc = ry * circ-const
  cx = rx
  cy = ry
  arc1 = [matrix(2,4): 0, rxc, rx, rx,
    (-1 * ry), (-1 * ry), (-1 * ryc), 0]
  arc2 = [matrix(2,3):  rx, rxc, 0,
    ryc, ry, ry]
  arc3 = [matrix(2,3):  (-1 * rxc), (-1 * rx), (-1 * rx),
    ry, ryc, 0]
  arc4 = [matrix(2,3):  (-1 * rx), (-1 * rxc), 0,
    (-1 * ryc), (-1 * ry), (-1 * ry)]
      
  mtx = translate(arc1.augment(arc2).augment(arc3).augment(arc4),[vector: cx, cy])
  bezier-shape(mtx, mode, color, posn(rx, ry)).intref(PKEY).get-self().snap-axes()
end
# line()
# Represents a line going from point
#   (0,0) to point (x,y) of the given color
fun line(x     :: Number,
    y     :: Number,
    color :: Color) :
  polygon([matrix(2,2): 0, x, 0, y], outline, color, posn(x / 2, y / 2)).intref(PKEY).get-self().snap-axes()
end

# Only called internally
# (Implemented using angle/pull definition found
#  in Barland, Findler, and Flatt 2010
#  ["The Design of a Functional Image Library"] and
#  curve-segment->path in gui-lib/mrlib/image-core.rkt)
fun curve(angle1, pull1, x, y, angle2, pull2, pen-or-color):
  length = num-sqrt(num-sqr(x) + num-sqr(y))
  theta1 = to-radians(angle1)
  theta2 = to-radians(angle2)
  handle1-x = pull1 * num-cos(theta1) * length
  handle1-y = pull1 * num-sin(theta1) * length
  handle2-x = x - (pull2 * num-cos(theta2) * length)
  handle2-y = y - (pull2 * num-sin(theta2) * length)
  pts = [matrix(2,4): 0, handle1-x, handle2-x, x, 0, handle1-y, handle2-y, y]
  cb = IM_MTX.cubic-bezier-bounding-box(posn(0, 0), posn(handle1-x, handle1-y), 
    posn(handle2-x, handle2-y), posn(x, y))
  bezier-shape(pts, outline, pen-or-color, cb.get-center())
end
  
# # text()
# # Represents the given string
# #   of text, using the given
# #   font size and color
# fun make-text(string :: String,
#     size   :: Number%(num-is-positive),
#     color  :: Color):
#   text(string, size, color, posn(0,0)) #TODO: Text dimensions
# end
# # text-font()
# # Represents the given string
# #   of text with the given font
# #   specification
# fun make-text-font(string      :: String,
#     size        :: Number%(num-is-positive),
#     color       :: Color,
#     font-face   :: String, #TODO: Font Face datatype?
#     font-family :: String, #TODO: Font Family datatype?
#     style       :: String,
#     weight      :: String,
#     underline   :: Boolean):
#   text-font(string, size, color, font-face, 
#     font-family, style, weight, 
#     underline, posn(0,0))
# end

# 
# Helper functions (ported from Racket)
# (Put in an object for organization)
#

helpers = {
  excess : lam(a :: Number%(num-is-positive), b :: Number%(num-is-positive), c :: Number%(num-is-positive)): 
    (num-sqr(a) + num-sqr(b)) - num-sqr(c) end,
  polar-to-posn : lam(radius :: Number%(num-is-positive), angle :: Number): 
    posn(radius * num-cos(angle), radius * num-sin(angle)) end,
  cos-rel : lam(a :: Number, b :: Number, C :: Number):
    (num-sqr(a) + num-sqr(b)) - (2 * a * b * num-cos(C)) end,
  sin-rel : lam(A :: Number, a :: Number, B :: Number):
    ((a * num-sin(B)) / num-sin(A)) end,
  last-angle : lam(A :: Number, B :: Number):
    ((pi - A) - B) end,
  radians : lam(degree :: Number):
    ((degree / 180.0) * pi) end
}

fun regular-polygon-points(side-length, side-count):
  doc: "Returns a list of vertices for a regular polygon"
  fun add-polar(p :: Position, rad, angle):
    from-polar = helpers.polar-to-posn(rad, angle)
    posn(p.x + from-polar.x, p.y + from-polar.y)
  end
  var ret-lst = empty
  var p = posn(0,0)
  for each(i from range(1, side-count + 1).reverse()):
    ret-lst := link(p, ret-lst)
    p := add-polar(p, side-length, (-2 * pi * ((side-count - i) / side-count)))
  end
  ret-lst
end

fun star-points(in-small-rad, in-large-rad, points):
  small-rad = in-small-rad - 1
  large-rad = in-large-rad - 1
  roff = num-floor(large-rad / 2)
  var ret-lst = empty
  for each(i from range(1, points + 1)):
    this-p = i - 1
    theta1 = 2 * pi * (this-p / points)
    theta2 = 2 * pi * ((this-p - 1/2) / points)
    raw-p1 = helpers.polar-to-posn(small-rad, theta1)
    raw-p2 = helpers.polar-to-posn(large-rad, theta2)
    ret-lst := link(posn(large-rad + raw-p1.x, large-rad + raw-p1.y), 
                    link(posn(large-rad + raw-p2.x, large-rad + raw-p2.y), ret-lst))
  end
  ret-lst
end

#
# Vertex-creating functions (ported from Racket)
# (Put in an object for organization)
#

vertices = {
  triangle-sss : 
    lam(a, b, c):
      A = num-acos(helpers.excess(b, c, a) / (2 * b * c))
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-ass :
    lam(A, b, c):
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-sas :
    lam(a, B, c):
      b-sq = helpers.cos-rel(a, c, B)
      b = num-sqrt(b-sq)
      A = num-acos(helpers.excess(b, c, a) / (2 * b * c))
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-ssa :
    lam(a, b, C):
      c-sq = helpers.cos-rel(a, b, C)
      c = num-sqrt(c-sq)
      A = num-acos(helpers.excess(b, c, a) / (2 * b * c))
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-aas :
    lam(A, B, c):
      C = helpers.last-angle(A, B)
      b = helpers.sin-rel(C, c, B)
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-asa :
    lam(A, b, C):
      B = helpers.last-angle(A, C)
      c = helpers.sin-rel(B, b, C)
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-saa :
    lam(a, B, C):
      A = helpers.last-angle(B, C)
      b = helpers.sin-rel(A, a, B)
      c = helpers.sin-rel(A, a, C)
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end
}

fun make-polygon(shadow vertices :: List<Position>, mode :: Mode, color :: Color) :
  doc: "Creates a polygon with the given vertices, mode, and color"
  # Use an object to simulate a (values ...) expression
  add-point = lam(p :: Position, o :: Object): { x-list : link(p.x, o.x-list), y-list: link(p.y, o.y-list) } end
  lsts = vertices.foldr(add-point, { x-list : empty, y-list : empty })
  poly-matrix = M.lists-to-matrix([list: lsts.x-list, lsts.y-list])
  poly-box = poly-corner-box([list: lsts.x-list, lsts.y-list])
  polygon(poly-matrix, mode, color, poly-box.get-center()).intref(PKEY).get-self().snap-axes()
end

fun make-polygon-star(side-length, side-count, mode, color, adjust):
  make-polygon(adjust(regular-polygon-points(side-length, side-count)), mode, color)
end
    

# triangle()
# Represents an upward-pointing
#   equilateral triangle
fun triangle(side-length :: Number%(num-is-positive),
    mode        :: Mode,
    color       :: Color) :
  polygon([matrix(2,3): (side-length / 2), 0, side-length, 0, side-length * num-sin(pi / 3), side-length * num-sin(pi / 3)], 
    mode, color, posn((side-length / 2),(side-length / 2) * num-sin(pi / 3))).intref(PKEY).get-self().snap-axes()
end
# right-triangle()
# Represents a right triangle with
#   its right angle at the bottom
#   right and with leg lengths
#   side-length1 and side-length2
fun right-triangle(side-length1 :: Number%(num-is-positive),
    side-length2 :: Number%(num-is-positive),
    mode         :: Mode,
    color        :: Color) :
  make-polygon([list: posn(0, (-1 * side-length2)), posn(0, 0), posn(side-length1, 0)], mode, color)
end
# isosceles-triangle()
# Represents an isosceles triangle,
#   where the sides are of length 
#   side-length, and the angle
#   between the two equal-length
#   sides is angle-c
fun isosceles-triangle(side-length :: Number%(num-is-positive),
    angle-c     :: Number, # Degrees
    mode        :: Mode,
    color       :: Color) :
  offset = (helpers.radians(angle-c) / 2)
  shadow vertices = [list: posn(0, 0), 
                           helpers.polar-to-posn(side-length, (pi / 2) + offset), 
                           helpers.polar-to-posn(side-length, (pi / 2) - offset)]
  make-polygon(vertices, mode, color)
  
  #r-ang = to-radians(angle-c)
  #polygon([matrix(2,3):  0, (2 * (side-length * num-sin(angle-c / 2))), (side-length * num-sin(angle-c / 2)), (side-length * num-cos(angle-c / 2)), (side-length * num-cos(angle-c / 2)), 0], mode, color, posn(side-length * num-sin(r-ang / 2), side-length * num-cos(r-ang / 2))).snap-axes()
end
# triangle-sss()
# Represents a triangle with the
#   given side lengths
fun triangle-sss(side-a :: Number%(num-is-positive),
    side-b :: Number%(num-is-positive),
    side-c :: Number%(num-is-positive),
    mode   :: Mode,
    color  :: Color) :
  make-polygon(vertices.triangle-sss(side-a, side-b, side-c), mode, color)
end
# triangle-ass()
# Represents a triangle with the
#   given angle and two sides.(A-S-S)
fun triangle-ass(angle-a :: Number, # Degrees
   side-b  :: Number%(num-is-positive),
    side-c  :: Number%(num-is-positive),
    mode    :: Mode,
    color   :: Color) :
  
  make-polygon(vertices.triangle-ass(helpers.radians(angle-a), side-b, side-c), mode, color)
end
# triangle-sas()
# Represents a triangle with the
#   given angle and two sides.(S-A-S)
fun triangle-sas(side-a  :: Number%(num-is-positive),
    angle-b :: Number, # Degrees
    side-c  :: Number%(num-is-positive),
    mode    :: Mode,
    color   :: Color) :
  make-polygon(vertices.triangle-sas(side-a, helpers.radians(angle-b), side-c), mode, color)
end
# triangle-ssa()
# Represents a triangle with the
#   given angle and two sides.(S-S-A)
fun triangle-ssa(side-a  :: Number%(num-is-positive),
    side-b  :: Number%(num-is-positive),
    angle-c :: Number, # Degrees
    mode    :: Mode,
    color   :: Color) :
  make-polygon(vertices.triangle-ssa(side-a, side-b, helpers.radians(angle-c)), mode, color)
end
# triangle-aas()
# Represents a triangle with the
#   given angle and two sides.(A-A-S)
fun triangle-aas(angle-a :: Number, # Degrees
    angle-b :: Number, # Degrees
    side-c  :: Number%(num-is-positive),
    mode    :: Mode,
    color   :: Color) :
  make-polygon(vertices.triangle-aas(helpers.radians(angle-a), helpers.radians(angle-b), side-c), mode, color)
end
  # triangle-asa()
  # Represents a triangle with the
  #   given angle and two sides.(A-S-A)
fun triangle-asa(angle-a :: Number, # Degrees
                 side-b  :: Number%(num-is-positive),
                 angle-c :: Number, # Degrees
                 mode    :: Mode,
                 color   :: Color):
  make-polygon(vertices.triangle-asa(helpers.radians(angle-a), side-b, helpers.radians(angle-c)), mode, color)
end
  # triangle-saa()
  # Represents a triangle with the
  #   given angle and two sides.(S-A-A)
fun triangle-saa(side-a  :: Number%(num-is-positive),
                 angle-b :: Number, # Degrees
                 angle-c :: Number, # Degrees
                 mode    :: Mode,
                 color   :: Color) :
  make-polygon(vertices.triangle-saa(side-a, helpers.radians(angle-b), helpers.radians(angle-c)), mode, color)
end
  # square()
  # Represents a square of the given side length
fun square(side-length :: Number%(num-is-positive),
           mode        :: Mode,
           color       :: Color) :
  polygon([matrix(2,4):  0, 0, side-length, side-length,
      0, side-length, side-length, 0], mode, color, posn((side-length / 2), (side-length / 2))).intref(PKEY).get-self().snap-axes()
end
  # rectangle()
  # Represents a rectangle with the
  #   given two side lengths
fun make-rectangle(width  :: Number%(num-is-positive),
              height :: Number%(num-is-positive),
              mode   :: Mode,
              color  :: Color) :
  rectangle(polygon, width, height, mode, color)
end
  # rhombus()
  # Represents a rhombus with the given
  #   side length and the given top/bottom
  #   angle
fun rhombus(side-length :: Number%(num-is-positive),
            angle       :: Number, # Degrees
            mode        :: Mode,
            color       :: Color) :
  beta = (pi / 2) - (to-radians(angle) / 2)
      polygon([matrix(2,4): 0, side-length * num-cos(beta), 2 * (side-length * num-cos(beta)), side-length * num-cos(beta),
        side-length * num-sin(beta), 0, side-length * num-sin(beta), 2 * (side-length * num-sin(beta))], mode, color, posn((side-length * num-cos(beta)), (side-length * num-sin(beta)))).intref(PKEY).get-self().snap-axes()
end
  # star()
  # Represents a 5-pointed star of
  #   the given side length
fun star(side-length :: Number%(num-is-positive),
         mode        :: Mode,
         color       :: Color) :
  make-polygon-star(side-length, 5, mode, color, lam(l): reorder-step(l, 2) end)
end
      
  # radial-star()
  # Represents a star with the given
  #   amount of points; the outer
  #   points will be a distance of
  #   outer from the center, the inner
  #   a distance of inner
fun radial-star(point-count :: Number%(nonzero-nat),
                outer       :: Number%(num-is-positive),
                inner       :: Number%(num-is-positive),
                mode        :: Mode,
                color       :: Color) :
  make-polygon(star-points(outer, inner, point-count), mode, color)
end
  # star-sized()
  # Same as radial-star().
fun star-sized(point-count :: Number%(nonzero-nat),
               outer       :: Number%(num-is-positive),
               inner       :: Number%(num-is-positive),
               mode        :: Mode,
               color       :: Color) :
  radial-star(point-count, outer, inner, mode, color)
end
  # star-polygon()
  # Represents a regular star polygon,
  #   with every step-th vertex connected
fun star-polygon(side-length :: Number%(num-is-positive),
                 point-count :: Number%(nonzero-nat),
                 step        :: Number%(nonzero-nat),
                 mode        :: Mode,
                 color       :: Color) :
  make-polygon-star(side-length, point-count, mode, color, lam(l): reorder-step(l, step) end)
end
  # regular-polygon()
  # Represents a regular polygon
  #   with the given number of sides.
fun regular-polygon(length :: Number%(num-is-positive),
                    count  :: Number%(nonzero-nat),
                    mode   :: Mode,
                    color  :: Color) :
  make-polygon-star(length, count, mode, color, lam(x): x end)
end

###########################
# PREDICATES
###########################
fun is-polygon(i) -> Boolean:
  ImageT.test(i) and (i.intref(PKEY).get-self().image-type() == "Polygon")
end

fun is-bezier-shape(i) -> Boolean:
  ImageT.test(i) and (i.intref(PKEY).get-self().image-type() == "Bezier")
end

fun is-compound-image(i) -> Boolean:
  ImageT.test(i) and (i.intref(PKEY).get-self().image-type() == "Compound")
end

fun is-clipped-image(i) -> Boolean:
  ImageT.test(i) and (i.intref(PKEY).get-self().image-type() == "Clipped")
end

###########################
# IMAGE COMBINING FUNCTIONS
###########################

# Begin Helper Functions

fun new-box(i1 :: Image, x :: Number, y :: Number, i2 :: Image, i1-pinhole :: Position) -> Box:
  doc: "Returns the new box of the first image placed on the second at the given position"
  i1-int = i1.intref(PKEY).get-self()
  i2-int = i2.intref(PKEY).get-self()
  top-shift-x = x - (i1-pinhole.x)
  top-shift-y = y - (i1-pinhole.y)
  i1-int.translate([vector: top-shift-x, top-shift-y]).intref(
    PKEY).get-self().cornerbox().join(i2-int.cornerbox()).to-box()
end

fun new-center(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Position:
  doc: "Returns the center coordinate of the first given image placed on the second at the given position"
  nb = new-box(i1,x,y,i2, i1.intref(PKEY).get-self().get-center())
  posn(nb.width / 2, nb.height / 2)
end

fun pin-to-one(i :: Image, use-top :: Boolean) -> Image:
  fun pin-to-clipped-image(iref, pair, hidden):
    clipped-image(pin-to-one(pair, false), hidden)
  end
  fun pin-to-compound-image(iref, top, at, bottom, pin):
    tint = top.intref(PKEY).get-self()
    bint = bottom.intref(PKEY).get-self()
    dvec = calc-compound-vector(tint, bint, bint.get-center(), at)
    trans-topx-p = dvec.first  >= 0 
    trans-topy-p = dvec.get(1) >= 0
    dtx = if trans-topx-p: dvec.first  else: 0 end
    dty = if trans-topy-p: dvec.get(1) else: 0 end
    dbx = if trans-topx-p: 0 else: -1 * dvec.first  end
    dby = if trans-topy-p: 0 else: -1 * dvec.get(1) end
    top-trans-box = tint.cornerbox().translate(dtx, dty)
    bot-trans-box = bint.cornerbox().translate(dbx, dby)
    make-pin = if use-top: tint.make-pinhole else: bint.make-pinhole end
    joined = top-trans-box.join(bot-trans-box)
    rel-pin = if use-top: tint.get-pinhole() else: bint.get-pinhole() end
    pin-box = if use-top: top-trans-box else: bot-trans-box end
    real-pin = posn(pin-box.top-left.x + rel-pin.x, pin-box.top-left.y + rel-pin.y)
    new-pin = make-pin(real-pin.x - joined.top-left.x, real-pin.y - joined.top-left.y)
    compound-image(top, at, bottom, new-pin)
  end
  match-dict = {clipped-image : pin-to-clipped-image, compound-image : pin-to-compound-image}
  if (is-compound-image(i) or is-clipped-image(i)):
    custom-match(i, match-dict)
  else:
    i
  end
end

# Convienence functions:
pin-to-top = lam(i): pin-to-one(i, true) end
pin-to-bottom = lam(i): pin-to-one(i, false) end
  
# End Helper Functions

# Begin Overlay Functions
fun overlay(i1 :: Image, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second"
  i2-center = i2.intref(PKEY).get-self().get-center()
  pin-to-top(compound-image(i1, i2-center, i2, i2-center).intref(PKEY).get-self().snap-axes())
end

fun overlay-pinhole(i1 :: Image, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second using their pinholes"
  tpin = i1.intref(PKEY).get-self().get-pinhole()
  bpin = i2.intref(PKEY).get-self().get-pinhole()
  overlay-xy(i1, tpin.x - bpin.x, tpin.y - bpin.y, i2)
end

fun overlay-align(xp :: X-Place, yp :: Y-Place, i1 :: Image, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second with the given alignments"
  tb = i1.intref(PKEY).get-self().get-box()
  bb = i2.intref(PKEY).get-self().get-box()
  xpos = cases(X-Place) xp:
    | x-left => tb.width / 2
    | x-center => i2.intref(PKEY).get-self().get-center().x
    | x-right => bb.width - (tb.width / 2)
  end
  ypos = cases(Y-Place) yp:
    | y-top => tb.height / 2
    | y-center => i2.intref(PKEY).get-self().get-center().y
    | y-bottom => bb.height - (tb.height / 2)
  end
  new-c = new-center(i1,xpos,ypos,i2)
  pin-to-top(compound-image(i1, posn(xpos, ypos), i2, new-c).intref(PKEY).get-self().snap-axes())
end

fun overlay-offset(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second after shifting the second x pixels to the right and y down"
  i2-center = i2.intref(PKEY).get-self().get-center()
  at = posn(i2-center.x - x, i2-center.y - y)
  new-c = new-center(i1,at.x,at.y,i2)
  pin-to-top(compound-image(i1, at, i2, new-c).clear-pinhole().intref(PKEY).get-self().snap-axes())
end

fun overlay-align-offset(xp :: X-Place, yp :: Y-Place, i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second with the given alignments after shifting it x pixels to the right and y down"
  tb = i1.intref(PKEY).get-self().get-box()
  bb = i2.intref(PKEY).get-self().get-box()
  xpos = cases(X-Place) xp:
    | x-left => (tb.width / 2) - x
    | x-center => (i2.intref(PKEY).get-self().get-center().x - x)
    | x-right => (bb.width - (tb.width / 2)) - x
  end
  ypos = cases(Y-Place) yp:
    | y-top => (tb.height / 2) - y
    | y-center => (i2.intref(PKEY).get-self().get-center().y - y)
    | y-bottom => (bb.height - (tb.height / 2)) - y
  end
  new-c = new-center(i1,xpos,ypos,i2)
  pin-to-top(compound-image(i1, posn(xpos, ypos), i2, new-c).intref(PKEY).get-self().snap-axes())
end

fun overlay-xy(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  # Identical to underlay-xy(i2,(-1 * x), (-1 * y), i1)
  doc: "Overlays the first image onto the second. The images are initially lined up on their upper-left corners and then the bottom one is shifted to the right by x to and down by y."
  tb = i1.intref(PKEY).get-self().get-box()
  at = posn((tb.width / 2) - x, (tb.height / 2) - y)
  new-c = new-center(i1, at.x, at.y, i2)
  pin-to-top(compound-image(i1, at, i2, new-c).intref(PKEY).get-self().snap-axes())
end

# End Overlay Functions

# Begin Underlay Functions

fun underlay(i1 :: Image, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second (like overlay, but in reverse order)"
  pin-to-bottom(overlay(i2, i1))
end

fun underlay-pinhole(i1 :: Image, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second using their pinholes"
  pin-to-bottom(overlay-pinhole(i2,i1))
end

fun underlay-align(xp :: X-Place, yp :: Y-Place, i1 :: Image, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second with the given alignments"
  pin-to-bottom(overlay-align(xp, yp, i2, i1))
end


fun underlay-offset(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second, after offsetting it right and down by the given amount"
  pin-to-bottom(overlay-offset(i2, (-1 * x), (-1 * y), i1))
end

fun underlay-align-offset(xp :: X-Place, yp :: Y-Place, i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second with the given alignments, after offsetting it right and down by the given amount"
  pin-to-bottom(overlay-align-offset(xp, yp, i2, (-1 * x), (-1 * y), i1))
end

fun underlay-xy(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second by aligning their top left corners and shifting the second right and down by the given amount"
  pin-to-bottom(overlay-xy(i2, (-1 * x), (-1 * y), i1))
end

fun beside(i1 :: Image, i2 :: Image) -> Image:
  doc: "Places the second image next to the first, with their centers vertically aligned"
  i1-int = i1.intref(PKEY).get-self()
  i2-int = i2.intref(PKEY).get-self()
  first-is-left = i1-int.get-center().x <= i2-int.get-center().x
  fb = i1-int.get-box()
  sb = i2-int.get-box()
  at = posn(fb.width + (sb.width / 2), i1-int.get-center().y)
  new-c = new-center(i2,at.x,at.y,i1)
  pin-to-bottom(compound-image(i2,at,i1,new-c).intref(PKEY).get-self().snap-axes())
end

fun beside-list(imgs :: List<Image>) -> Image:
  doc: "Places the list of images next to one another, with the first image on the left"
  swapped = lam(i1, i2): beside(i2, i1) end
  imgs.rest.foldl(swapped,imgs.first)
end

fun beside-align(yp :: Y-Place, i1 :: Image, i2 :: Image) -> Image:
  doc: "Places the second image next to the first, with the given vertical alignment"
  i1-int = i1.intref(PKEY).get-self()
  i2-int = i2.intref(PKEY).get-self()
  fb = i1-int.get-box()
  sb = i2-int.get-box()
  xpos = fb.width + (sb.width / 2)
  ypos = cases(Y-Place) yp:
    | y-top => (sb.height / 2)
    | y-center => i1-int.get-center().y
    | y-bottom => fb.height - (sb.height / 2)
  end
  new-c = new-center(i2, xpos, ypos, i1)
  pin-to-bottom(compound-image(i2,posn(xpos,ypos),i1,new-c).intref(PKEY).get-self().snap-axes())
end

fun beside-align-list(yp :: Y-Place, imgs :: List<Image>) -> Image:
  doc: "Places the list of images next to one another with the given alignment, with the first image on the left"
  with-yp = lam(i2, i1): beside-align(yp, i1, i2) end
  imgs.rest.foldl(with-yp,imgs.first)
end

fun above(i1 :: Image, i2 :: Image) -> Image:
  doc: "Places the first image above the second, with their centers horizontally aligned"
  i1-int = i1.intref(PKEY).get-self()
  i2-int = i2.intref(PKEY).get-self()
  i1cb = i1-int.cornerbox()
  i2cb = i2-int.cornerbox()
  i1-box = i1cb.to-box()
  i1-center = i1cb.get-center()
  i2-box = i2cb.to-box()
  at-x = i1-center.x
  at-y = i1-box.height + i2cb.get-center().y
  at = posn(at-x, at-y)
  new-c = new-center(i2,at.x,at.y,i1)
  pin-to-bottom(compound-image(i2,at,i1,new-c).intref(PKEY).get-self().snap-axes())
end

fun above-list(imgs :: List<Image>) -> Image:
  doc: "Places the list of images on top of one another, with the first image on the top"
  swapped = lam(i1, i2): above(i2, i1) end
  imgs.rest.foldl(swapped, imgs.first)
end

fun above-align(xp :: X-Place, i1 :: Image, i2 :: Image) -> Image:
  doc: "Places the first image above the second, with the given horizontal alignment"
  i1-int = i1.intref(PKEY).get-self()
  i2-int = i2.intref(PKEY).get-self()
  i1cb = i1-int.cornerbox()
  i1-box = i1cb.to-box()
  i1-center = i1cb.get-center()
  i2cb = i2-int.cornerbox()
  i2-box = i2cb.to-box()
  i2-center = i2cb.get-center()
  xpos = cases(X-Place) xp:
    | x-left => i2-center.x
    | x-center => i1-center.x
    | x-right => i1-box.width - i2-center.x
  end
  ypos = i1-box.height + i2-center.y
  new-c = new-center(i2,xpos,ypos,i1)
  pin-to-bottom(compound-image(i2, posn(xpos, ypos), i1, new-c).intref(PKEY).get-self().snap-axes())
end

fun above-align-list(xp :: X-Place, imgs :: List<Image>) -> Image:
  doc: "Places the list of images on top of one another with the given alignment, with the first image on top"
  with-xp = lam(i1, i2): above-align(xp, i2, i1) end
  imgs.rest.foldl(with-xp, imgs.first)
end

fun empty-scene(x :: Number%(num-is-positive),
                y :: Number%(num-is-positive)) :
  overlay(make-rectangle(x,y,outline,black), make-rectangle(x,y,solid,white))
end

fun colored-empty-scene(x :: Number%(num-is-positive),
                y :: Number%(num-is-positive),
                k :: Color) :
  overlay(make-rectangle(x,y,outline,black), make-rectangle(x,y,solid,k))
end

fun place-image-topleft(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  tb = i1.intref(PKEY).get-self().get-box()
  at = posn((tb.width / 2) + x, (tb.height / 2) + y)
  pin-to-bottom(clipped-image(compound-image(i1, at, i2, i2.intref(PKEY).get-self().get-center()), false))
end

fun overlay-at(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  pin-to-top(compound-image(i1, posn(x,y), i2, i2.intref(PKEY).get-self().get-center()))
end

fun place-image(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Places the first image onto the second, clipping it so that it is no larger than the bottom"
  if not(is-clipped-image(i2)):
    clipped-image(compound-image(i1, posn(x,y), i2, i2.intref(PKEY).get-self().get-center()),false)
  else:
    # Combine the tops to avoid unneeded mask propogation
    i2-int = i2.intref(PKEY).get-self()
    i2-pair = i2-int.pair.intref(PKEY).get-self()
    i2-top = i2-pair.top.intref(PKEY).get-self()
    trans-vec = [vector: i2-pair.at.x - i2-top.get-center().x, 
      i2-pair.at.y - i2-top.get-center().y]
    basis = i2-top.translate(trans-vec).intref(PKEY).get-self().coord-zero()
    comb-at = posn(x - basis.x, y - basis.y)
    new-top = pin-to-bottom(compound-image(i1, comb-at, i2-pair.top, new-center(i1, comb-at.x, comb-at.y, i2-pair.top)))
    new-top-int = new-top.intref(PKEY).get-self()
    diff-c = posn(i2-top.get-center().x - new-top-int.get-center().x, 
                  i2-top.get-center().y - new-top-int.get-center().y)
    new-at = posn(i2-pair.at.x - diff-c.x, i2-pair.at.y - diff-c.y)
    pin-to-bottom(clipped-image(compound-image(new-top, new-at, i2-pair.bottom, i2-pair.get-center()), i2-int.hidden-mask))
  end
end

fun place-images(imgs :: List<Image>, posns :: List<Position>, base :: Image) -> Image:
  doc: "Places the given list of images onto the given base image (the first being on top) at the given positions"
  placelam = lam(acc, i, p): place-image(i, p.x, p.y, acc) end
  fold2(placelam,base,imgs,posns)
end

fun place-image-align(i1 :: Image, x :: Number, y :: Number, xp :: X-Place, yp :: Y-Place, i2 :: Image):
  tb = i1.intref(PKEY).get-self().get-box()
  xpos = cases(X-Place) xp:
    | x-left => (tb.width / 2) + x
    | x-center => x
    | x-right => (-1 * (tb.width / 2)) + x
  end
  ypos = cases(Y-Place) yp:
    | y-top => (tb.height / 2) + y
    | y-center => y
    | y-bottom => (-1 * (tb.height / 2)) + y
  end
  place-image(i1, xpos, ypos, i2)
end

fun place-images-align(imgs :: List<Image>, 
                       posns :: List<Position>, 
                       x-place :: X-Place, 
                       y-place :: Y-Place, 
                       scene :: Image) -> Image:
  placelam = lam(acc, i, p): place-image-align(i, p.x, p.y, x-place, y-place, acc) end
  fold2(placelam, scene, imgs, posns)
end

############
# OTHER IMAGE FUNCTIONS
############

fun frame(i :: Image) -> Image:
  doc: "Returns the given image with a black frame around it"
  bb = i.intref(PKEY).get-self().get-box()
  overlay(make-rectangle(bb.width, bb.height, outline, black), i)
end

############
# MORE LINES AND CURVES
############

fun add-line(image :: Image, x1 :: Number, y1 :: Number, x2 :: Number, y2 :: Number, pen-or-color :: Color) -> Image:
  doc: "Adds a line to the given image"
  dx = x2 - x1
  dy = y2 - y1
  line-to-add = line(dx, dy, pen-or-color)
  overlay-xy(line-to-add, -1 * num-min(x1, x2), -1 * num-min(y1, y2), image)
end

fun add-line-to-scene(scene :: Image, 
                      x1 :: Number, 
                      y1 :: Number, 
                      x2 :: Number, 
                      y2 :: Number, 
                      pen-or-color :: Color) -> Image:
  doc: "Adds a line to the given scene, cropping the resulting image to the size of scene"
  dx = x2 - x1
  dy = y2 - y1
  line-to-add = line(dx, dy, pen-or-color)
  place-image-topleft(line-to-add, num-min(x1, x2), num-min(y1, y2), scene)
end

fun add-curve(image :: Image, 
              x1 :: Number,
              y1 :: Number,
              angle1 :: Number,
              pull1 :: Number,
              x2 :: Number,
              y2 :: Number,
              angle2 :: Number,
              pull2 :: Number,
              pen-or-color :: Color) -> Image:
  dx = x2 - x1
  dy = y2 - y1
  leftx = num-min(x1, x2)
  rightx = num-max(x1, x2)
  topy = num-min(y1, y2)
  boty = num-max(y1, y2)
  place-at = cornerbox(posn(leftx, topy), posn(rightx, boty)).get-center()
  curve-to-add = curve(angle1, pull1, dx, dy, angle2, pull2, pen-or-color)
  overlay-at(curve-to-add, place-at.x, place-at.y, image)
end

fun add-curve-to-scene(scene :: Image,
                       x1 :: Number,
                       y1 :: Number,
                       angle1 :: Number,
                       pull1 :: Number,
                       x2 :: Number,
                       y2 :: Number,
                       angle2 :: Number,
                       pull2 :: Number,
                       pen-or-color :: Color) -> Image:
  dx = x2 - x1
  dy = y2 - y1
  leftx = num-min(x1, x2)
  rightx = num-max(x1, x2)
  topy = num-min(y1, y2)
  boty = num-max(y1, y2)
  place-at = cornerbox(posn(leftx, topy), posn(rightx, boty)).get-center()
  curve-to-add = curve(angle1, pull1, dx, dy, angle2, pull2, pen-or-color)
  place-image(curve-to-add, place-at.x, place-at.y, scene)
end

############
# MORE POLYGONS
############
fun make-polygon-from-points(shadow vertices :: List<Position>, mode :: Mode, color :: Color) -> Image:
  x-list = vertices.map(lam(p): p.x end)
  y-list = vertices.map(lam(p): p.y end)
  mtx = M.lists-to-matrix([list: x-list, y-list])
  cb = poly-corner-box([list: x-list, y-list])
  polygon(mtx, mode, color, cb.get-center()).intref(PKEY).get-self().snap-axes()
end

fun add-polygon(image :: Image, posns :: List<Position>, mode :: Mode, color :: Color) -> Image:
  x-list = posns.map(lam(p): p.x end)
  y-list = posns.map(lam(p): p.y end)
  mtx = M.lists-to-matrix([list: x-list, y-list])
  cb = poly-corner-box([list: x-list, y-list])
  true-center = cb.get-center()
  poly = polygon(mtx, mode, color, cb.get-center()).intref(PKEY).get-self().snap-axes()
  overlay-at(poly, true-center.x, true-center.y, image)
end

fun add-polygon-to-scene(image :: Image, posns :: List<Position>, mode :: Mode, color :: Color) -> Image:
  x-list = posns.map(lam(p): p.x end)
  y-list = posns.map(lam(p): p.y end)
  mtx = M.lists-to-matrix([list: x-list, y-list])
  cb = poly-corner-box([list: x-list, y-list])
  center = cb.get-center()
  poly = polygon(mtx, mode, color, cb.get-center()).intref(PKEY).get-self().snap-axes()
  place-image(poly, center.x, center.y, image)
end

############
# SVG RENDERING FUNCTIONS
############

fun raw-svg-rect(top-left :: Position, width :: Number, height :: Number):
  x-attr = XML.attribute("x", XML.atomic(top-left.x))
  y-attr = XML.attribute("y", XML.atomic(top-left.y))
  width-attr = XML.attribute("width", XML.atomic(width))
  height-attr = XML.attribute("height", XML.atomic(height))
  style-attr = XML.attribute("style", XML.atomic("fill:none;stroke:black;stroke-width:1;"))
  XML.tag("rect", [list: x-attr, y-attr, width-attr, height-attr, style-attr], empty)
end

fun raw-svg-dot(pos :: Position):
  x-attr = XML.attribute("cx", XML.atomic(pos.x))
  y-attr = XML.attribute("cy", XML.atomic(pos.y))
  radius-attr = XML.attribute("r", XML.atomic(3))
  stroke-attr = XML.attribute("stroke", XML.atomic("black"))
  stroke-width-attr = XML.attribute("stroke-width", XML.atomic(1))
  fill-attr = XML.attribute("fill", XML.atomic("none"))
  XML.tag("circle", [list: x-attr, y-attr, radius-attr, stroke-attr, stroke-width-attr, fill-attr], empty)
end

fun svg-pinhole-lines(intersection :: Position, img-width :: Number, img-height :: Number):
  black-attr = XML.attribute("stroke", XML.atomic("black"))
  white-attr = XML.attribute("stroke", XML.atomic("white"))
  stroke-width-attr = XML.attribute("stroke-width", XML.atomic(1))
  fun vert-line(x-pos :: Number, color :: XML.Attribute):
    x1 = XML.attribute("x1", XML.atomic(x-pos))
    x2 = XML.attribute("x2", XML.atomic(x-pos))
    y1 = XML.attribute("y1", XML.atomic(0))
    y2 = XML.attribute("y2", XML.atomic(img-height))
    XML.tag("line", [list: x1, x2, y1, y2, color, stroke-width-attr], empty)
  end
  fun horiz-line(y-pos :: Number, color :: XML.Attribute):
    x1 = XML.attribute("x1", XML.atomic(0))
    x2 = XML.attribute("x2", XML.atomic(img-width))
    y1 = XML.attribute("y1", XML.atomic(y-pos))
    y2 = XML.attribute("y2", XML.atomic(y-pos))
    XML.tag("line", [list: x1, x2, y1, y2, color, stroke-width-attr], empty)
  end
  white-intersect = posn(intersection.x + 1/2, intersection.y + 1/2)
  black-intersect = posn(intersection.x - 1/2, intersection.y - 1/2)
  bvert  =  vert-line(black-intersect.x, black-attr)
  bhoriz = horiz-line(black-intersect.y, black-attr)
  wvert  =  vert-line(white-intersect.x, white-attr)
  whoriz = horiz-line(white-intersect.y, white-attr)
  XML.tag("g", empty, [list: bvert, bhoriz, wvert, whoriz])
end

fun num-inexact-string(n :: Number) -> String:
  doc: "Returns a string with a decimal representation of the given number"
  num-to-string-digits(num-exact(n), 10)
end

fun point-to-string(pt :: Position):
  num-inexact-string(pt.x) + "," + num-inexact-string(pt.y) + " "
where:
  point-to-string(posn(25,34)) is "25,34 "
end

fun draw-polygon(img :: Image%(is-polygon)) -> XML.Element:
  doc: "Returns the <polygon> tag corresponding to the given polygon"
  fun extract-polygon-info(iref, mtx, mode, color, pin):
    {matrix : mtx, mode : mode, color : color, pin : pin}
  end
  i = img.intref(PKEY).get-self()
  points = XML.attribute("points", XML.atomic(for fold(acc from "", p from matrix-to-posns(i.matrix)):
    acc + point-to-string(p)
  end))
  style-attributes = cases(Mode) i.mode:
    | solid => i.color.solid-xml-attributes()
    | outline => link(XML.attribute("fill", XML.atomic("none")), i.color.outline-xml-attributes())
  end
  XML.tag("polygon", link(points, style-attributes), empty)
end

fun draw-bezier-shape(img :: Image%(is-bezier-shape)) -> XML.Element:
  doc: "Returns the <path> tag corresponding to the given bezier-curve-defined shape"
  # USAGE: (note: i.matrix.cols % 3 == 1)
  # The first position in the matrix is the move-to point
  #   and the remaining ones are Cubic Bezier control points
  # IF YOU DON'T KNOW WHAT THAT MEANS YOU SHOULDN'T BE CALLING THIS
  fun curve-string(lst :: List<Position>):
    if not(num-modulo(lst.length(),3) == 0):
      raise("Invalid Bezier Shape")
    else:
      fun recur-string(acc, l :: List<Position>):
        cases(List) l:
          | empty => acc
          | link(f,r) => recur-string(acc + ("C " + fold(string-append, "",map(point-to-string,l.take(3)))), l.drop(3))
        end
      end
      recur-string("",lst)
    end
  end
  
  fun extract-bezier-info(iref, mtx, mode, color, pin):
    {matrix : mtx, mode : mode, color : color, pin : pin}
  end
  i = img.intref(PKEY).get-self()

  raw-pts = matrix-to-posns(i.matrix)
   
  points = XML.attribute("d", XML.atomic("M" + (point-to-string(raw-pts.first) + curve-string(raw-pts.rest))))
  
  style-attributes = cases(Mode) i.mode:
    | solid => i.color.solid-xml-attributes()
    | outline => link(XML.attribute("fill", XML.atomic("none")), i.color.outline-xml-attributes())
  end
  XML.tag("path", link(points, style-attributes), empty)
end

fun wrap-and-name(prefix :: Number, n :: Number, elt :: XML.Element) -> XML.Element:
  id-str = XML.attribute("id", XML.atomic(num-tostring(prefix) + "_" + num-tostring(n)))
  shape-id-str = XML.attribute("id", XML.atomic(num-tostring(prefix) + "_" + num-tostring(n) + "_shape"))
  new-elt = XML.tag(elt.name, elt.attributes + [list: shape-id-str], elt.elts)
  XML.tag("clipPath", [list: id-str], [list: new-elt])
end

fun get-clip-union(prefix :: Number, clips :: List<XML.Element>, width :: Number, height :: Number) -> List<XML.Element>:
  len = clips.length()
  when len == 0:
    raise("Cannot clip image without clip")
  end
  id-att = lam(num): XML.attribute("id", XML.atomic(num-tostring(prefix) + "_" + num-tostring(num) + "_clip")) end
  first-path-att = lam(num): XML.attribute("clip-path", XML.atomic("url(#" + num-tostring(prefix) + "_" + num-tostring(num) + ")")) end
  path-att = lam(num): XML.attribute("clip-path", XML.atomic("url(#" + num-tostring(prefix) + "_" + num-tostring(num) + "_clip)")) end
  shape-id = lam(num): num-tostring(prefix) + "_" + num-tostring(num) + "_shape" end
  use-tag = lam(num): XML.tag("use", [list: 
        XML.attribute("x",XML.atomic("0")), 
        XML.attribute("y",XML.atomic("0")), 
        XML.attribute("width",XML.atomic(width)), 
        XML.attribute("height",XML.atomic(height)), 
        XML.attribute("xlink:href",XML.atomic("#" + shape-id(num)))], empty) 
  end
  main-id = id-att(0)
  contents = range(0, num-max(1, len - 2)).map(use-tag)
  [list: XML.tag("clipPath", [list: main-id], contents)]
end

data ClipInfo:
  | clip-pair(defs :: XML.Element, useClip :: String)
end

fun add-clip(name :: String, to :: XML.Element) -> XML.Element:
  XML.tag(to.name, to.attributes + [list: XML.attribute("clip-path",XML.atomic(name))], to.elts)
end

fun get-clip(img :: Image%(is-clipped-image), fit-all :: Boolean) -> ClipInfo:
  doc: "Returns the clip for the given clipped image"
  fun extract-clipped-info(iref, pair, hidden):
    {pair : pair, hidden : hidden}
  end
  fun extract-compound-bottom(iref, top, at, bottom, pin):
    bottom
  end
  i = img.intref(PKEY).get-self()
  i-pair = i.pair.intref(PKEY).get-self()
  i-bottom = i-pair.bottom
  bbox = i-pair.get-box()
  shapes = draw-prerendered-svg(i-bottom, fit-all)
  prefix = num-random(10000) # TODO: Find a better way to avoid n.s. collisions
  wrapped = for map2(n from range(0,shapes.length()), elt from shapes):
    wrap-and-name(prefix, n, elt)
  end
  defs = XML.tag("defs", empty, wrapped + get-clip-union(prefix, wrapped, bbox.width, bbox.height))
  to-use = defs.elts.last().attributes.first.value.val # That's a mouthful
  clip-pair(defs, "url(#" + to-use + ")")
end

fun draw-prerendered-svg(i :: Image, fit-all :: Boolean) -> List<XML.Element>:
  doc: "Returns the list of XML elements corresponding to the given pre-rendered image"
  i-int = i.intref(PKEY).get-self()
  fun draw-compound-image(iref, top, at, bottom, pin):
    int-top = top.intref(PKEY).get-self()
    int-bottom = bottom.intref(PKEY).get-self()
    dy = if fit-all: num-max(0, int-bottom.snap-vec().get(1)) else: 0 end
    # basis needed for translating from relative positioning
    # to absolute positioning
    i-center = i-int.get-center()
    basis = int-bottom.coord-zero()
    top-basis = int-top.coord-zero()
    true-at = posn(at.x + basis.x, at.y + basis.y)
    pre-trans-top = int-top.translate([vector: (true-at.x - int-top.get-center().x), (true-at.y - int-top.get-center().y) + dy]).intref(PKEY).get-self()
    top-vec = if fit-all: pre-trans-top.snap-vec() else: [vector: 0, 0] end
    top-dx = num-max(0, top-vec.first)
    top-dy = num-max(0, top-vec.get(1))
    mid-trans-top = pre-trans-top.translate([vector: top-dx, top-dy]).intref(PKEY).get-self()
    mid-trans-bot = int-bottom.translate([vector: top-dx, dy + top-dy]).intref(PKEY).get-self()
    mtrans-cb = mid-trans-top.cornerbox().join(mid-trans-bot.cornerbox())
    mtrans-center = mtrans-cb.get-center()
    center-vec = if fit-all: [vector: num-max(0, i-center.x - mtrans-center.x), num-max(0, i-center.y - mtrans-center.y)] else: [vector: 0, 0] end
    draw-prerendered-svg(mid-trans-bot.translate(center-vec), fit-all).append(
      draw-prerendered-svg(mid-trans-top.translate(center-vec), fit-all))
  end
  fun draw-clipped-image(iref, rawpair, hide-bottom):
    clip = get-clip(i, fit-all)
    clip-add = lam(e): add-clip(clip.useClip, e) end
    fun extract-compound-info(icref, top, at, bottom, pin):
      {top : top.intref(PKEY).get-self(), at : at, bottom : bottom.intref(PKEY).get-self(), pin : pin}
    end
    pair-prot = rawpair.intref(PKEY).get-self()
    pair = extract-compound-info(pair-prot, pair-prot.top, pair-prot.at, pair-prot.bottom, pair-prot.pinhole)
    dy = if fit-all: num-max(0, pair.bottom.snap-vec().get(1)) else: 0 end
    basis = pair.bottom.coord-zero()
    true-at = posn(pair.at.x + basis.x, pair.at.y + basis.y)
    trans-top = pair.top.translate([vector: (true-at.x - pair.top.get-center().x), 
                                            (true-at.y - pair.top.get-center().y) + dy])
    if not(hide-bottom):
      [list: clip.defs] + map(clip-add, draw-prerendered-svg(pair.bottom.translate([vector: 0, dy]), 
        fit-all).append(draw-prerendered-svg(trans-top, false)))
    else:
      [list: clip.defs] + map(clip-add, draw-prerendered-svg(trans-top, false))
    end
  end
  ask:
    | is-compound-image(i) then: custom-match(i, {compound-image : draw-compound-image})
    | is-clipped-image(i) then: custom-match(i, {clipped-image : draw-clipped-image})
    | is-polygon(i) then: [list: draw-polygon(i)]
    | is-bezier-shape(i) then: [list: draw-bezier-shape(i)]
    | otherwise: raise('Fatal error: Unknown image type in object: ' + torepr(i))
  end
end

fun list-min<X>(lst :: List<X>) -> X:
  doc: "Returns the minimal element of the given list"
  retless = lam(a,b): if a < b: a else: b end end
  cases(List) lst:
    | link(_,_) => fold(retless, lst.first, lst.rest)
    | empty => raise("Cannot find the least element of an empty list")
  end
where:
  list-min([list: 4, 2, 6, 3, 7, 4, 1, 3, 8]) is 1
  list-min([list: -30, 2, 5, 2, 6]) is -30
end


fun draw-svg(i :: Image) -> XML.Element:
  doc: "Returns an SVG element representation of the given image"
  # Current status: Spits out <svg> tag in REPR. Copy/paste somewhere
  #   such as http://scriptdraw.com/ to view, or use a Tampermonkey
  #   script made by Philip (email (see top) for a copy)
  i-int = i.intref(PKEY).get-self()
  pre = draw-prerendered-svg(i, true) # Returns all <polygon> and <path> tags
  b = i-int.svg-size()
  ht = XML.attribute("height", num-exact(b.height))
  wd = XML.attribute("width", num-exact(b.width))
  i-pin = i-int.get-pinhole()
  ibox = i-int.get-box()
  maybe-pin-svg = if is-explicit-posn(i-pin): 
      svg-pinhole-lines(i-pin, ibox.width, ibox.height) 
    else:
      XML.tag("g", empty, empty)
    end
  attrs = 
  if ((is-polygon(i) or is-bezier-shape(i)) and (i-int.get-mode() == outline)): 
    [list: wd, ht, XML.attribute("style", "overflow:visible;")]
  else:
    [list: wd, ht]
  end
  # Append to make sure that the pinhole is on top
  XML.tag("svg", attrs, pre.append([list: maybe-pin-svg]))
end

fun draw-debug(i :: Image) -> XML.Element:
  i-int = i.intref(PKEY).get-self()
  cb = i-int.cornerbox()
  cb-as-box = cb.to-box()
  shadow frame = raw-svg-rect(cb.top-left, cb-as-box.width, cb-as-box.height)
  center-dot = raw-svg-dot(i-int.get-center())
  cases(XML.Element) draw-svg(i):
    | tag(tname, attrs, pre) => XML.tag(tname, attrs, pre.append([list: frame, center-dot]))
  end
end
provide {
  rgba-color : IM_D.rgba-color,
  rgb-color : IM_D.rgb-color,
  orangered : IM_D.orangered,
  tomato : IM_D.tomato,
  darkred : IM_D.darkred,
  red : IM_D.red,
  firebrick : IM_D.firebrick,
  crimson : IM_D.crimson,
  deeppink : IM_D.deeppink,
  maroon : IM_D.maroon,
  indianred : IM_D.indianred,
  mediumvioletred : IM_D.mediumvioletred,
  violetred : IM_D.violetred,
  lightcoral : IM_D.lightcoral,
  hotpink : IM_D.hotpink,
  palevioletred : IM_D.palevioletred,
  lightpink : IM_D.lightpink,
  rosybrown : IM_D.rosybrown,
  pink : IM_D.pink,
  orchid : IM_D.orchid,
  lavenderblush : IM_D.lavenderblush,
  snow : IM_D.snow,
  chocolate : IM_D.chocolate,
  saddlebrown : IM_D.saddlebrown,
  brown : IM_D.brown,
  darkorange : IM_D.darkorange,
  coral : IM_D.coral,
  sienna : IM_D.sienna,
  orange : IM_D.orange,
  salmon : IM_D.salmon,
  peru : IM_D.peru,
  darkgoldenrod : IM_D.darkgoldenrod,
  goldenrod : IM_D.goldenrod,
  sandybrown : IM_D.sandybrown,
  lightsalmon : IM_D.lightsalmon,
  darksalmon : IM_D.darksalmon,
  gold : IM_D.gold,
  yellow : IM_D.yellow,
  olive : IM_D.olive,
  burlywood : IM_D.burlywood,
  tan : IM_D.tan,
  navajowhite : IM_D.navajowhite,
  peachpuff : IM_D.peachpuff,
  khaki : IM_D.khaki,
  darkkhaki : IM_D.darkkhaki,
  moccasin : IM_D.moccasin,
  wheat : IM_D.wheat,
  bisque : IM_D.bisque,
  palegoldenrod : IM_D.palegoldenrod,
  blanchedalmond : IM_D.blanchedalmond,
  mediumgoldenrod : IM_D.mediumgoldenrod,
  papayawhip : IM_D.papayawhip,
  mistyrose : IM_D.mistyrose,
  lemonchiffon : IM_D.lemonchiffon,
  antiquewhite : IM_D.antiquewhite,
  cornsilk : IM_D.cornsilk,
  lightgoldenrodyellow : IM_D.lightgoldenrodyellow,
  oldlace : IM_D.oldlace,
  linen : IM_D.linen,
  lightyellow : IM_D.lightyellow,
  seashell : IM_D.seashell,
  beige : IM_D.beige,
  floralwhite : IM_D.floralwhite,
  ivory : IM_D.ivory,
  green : IM_D.green,
  lawngreen : IM_D.lawngreen,
  chartreuse : IM_D.chartreuse,
  greenyellow : IM_D.greenyellow,
  yellowgreen : IM_D.yellowgreen,
  mediumforestgreen : IM_D.mediumforestgreen,
  olivedrab : IM_D.olivedrab,
  darkolivegreen : IM_D.darkolivegreen,
  darkseagreen : IM_D.darkseagreen,
  lime : IM_D.lime,
  darkgreen : IM_D.darkgreen,
  limegreen : IM_D.limegreen,
  forestgreen : IM_D.forestgreen,
  springgreen : IM_D.springgreen,
  mediumspringgreen : IM_D.mediumspringgreen,
  seagreen : IM_D.seagreen,
  mediumseagreen : IM_D.mediumseagreen,
  aquamarine : IM_D.aquamarine,
  lightgreen : IM_D.lightgreen,
  palegreen : IM_D.palegreen,
  mediumaquamarine : IM_D.mediumaquamarine,
  turquoise : IM_D.turquoise,
  lightseagreen : IM_D.lightseagreen,
  mediumturquoise : IM_D.mediumturquoise,
  honeydew : IM_D.honeydew,
  mintcream : IM_D.mintcream,
  royalblue : IM_D.royalblue,
  dodgerblue : IM_D.dodgerblue,
  deepskyblue : IM_D.deepskyblue,
  cornflowerblue : IM_D.cornflowerblue,
  steelblue : IM_D.steelblue,
  lightskyblue : IM_D.lightskyblue,
  darkturquoise : IM_D.darkturquoise,
  cyan : IM_D.cyan,
  aqua : IM_D.aqua,
  darkcyan : IM_D.darkcyan,
  teal : IM_D.teal,
  skyblue : IM_D.skyblue,
  cadetblue : IM_D.cadetblue,
  darkslategray : IM_D.darkslategray,
  lightslategray : IM_D.lightslategray,
  slategray : IM_D.slategray,
  lightsteelblue : IM_D.lightsteelblue,
  lightblue : IM_D.lightblue,
  powderblue : IM_D.powderblue,
  paleturquoise : IM_D.paleturquoise,
  lightcyan : IM_D.lightcyan,
  aliceblue : IM_D.aliceblue,
  azure : IM_D.azure,
  mediumblue : IM_D.mediumblue,
  darkblue : IM_D.darkblue,
  midnightblue : IM_D.midnightblue,
  navy : IM_D.navy,
  blue : IM_D.blue,
  indigo : IM_D.indigo,
  blueviolet : IM_D.blueviolet,
  mediumslateblue : IM_D.mediumslateblue,
  slateblue : IM_D.slateblue,
  purple : IM_D.purple,
  darkslateblue : IM_D.darkslateblue,
  darkviolet : IM_D.darkviolet,
  darkorchid : IM_D.darkorchid,
  mediumpurple : IM_D.mediumpurple,
  mediumorchid : IM_D.mediumorchid,
  magenta : IM_D.magenta,
  fuchsia : IM_D.fuchsia,
  darkmagenta : IM_D.darkmagenta,
  violet : IM_D.violet,
  plum : IM_D.plum,
  lavender : IM_D.lavender,
  thistle : IM_D.thistle,
  ghostwhite : IM_D.ghostwhite,
  white : IM_D.white,
  whitesmoke : IM_D.whitesmoke,
  gainsboro : IM_D.gainsboro,
  lightgray : IM_D.lightgray,
  silver : IM_D.silver,
  gray : IM_D.gray,
  grey : IM_D.grey,
  darkgray : IM_D.darkgray,
  dimgray : IM_D.dimgray,
  black : IM_D.black,
  outline : IM_D.outline,
  solid : IM_D.solid,
  x-left : IM_D.x-left,
  x-center : IM_D.x-center,
  x-right : IM_D.x-right,
  y-top : IM_D.y-top,
  y-center : IM_D.y-center,
  y-bottom : IM_D.y-bottom,
  pen : IM_D.pen,
  style-dot : IM_D.style-dot,
  style-solid : IM_D.style-solid,
  style-long-dash : IM_D.style-long-dash,
  style-short-dash : IM_D.style-short-dash,
  style-dot-dash : IM_D.style-dot-dash,
  cap-round : IM_D.cap-round,
  cap-projecting : IM_D.cap-projecting,
  cap-butt : IM_D.cap-butt,
  join-bevel : IM_D.join-bevel,
  join-miter : IM_D.join-miter,
  join-round : IM_D.join-round,
  posn : IM_AUX_DATA.posn,
  box : IM_AUX_DATA.box,
  ivl : IM_AUX_DATA.ivl,
  vector-sub : IM_MTX.vector-sub,
  points-bounding-box : IM_MTX.points-bounding-box,
  list-of-points-bounding-box : IM_MTX.list-of-points-bounding-box,
  mtx-center : IM_MTX.mtx-center,
  translate : IM_MTX.translate,
  translate-posn : IM_MTX.translate-posn,
  trans-mtx : IM_MTX.trans-mtx,
  homogeneous-transform : IM_MTX.homogeneous-transform,
  transform-posn : IM_MTX.transform-posn,
  transform-posn-about : IM_MTX.transform-posn-about,
  affine-transform-matrix : IM_MTX.affine-transform-matrix,
  matrix-to-posns : IM_MTX.matrix-to-posns,
  matrices-to-posns : IM_MTX.matrices-to-posns,
  bezier-box : IM_MTX.bezier-box,
  bezier-snap-trans : IM_MTX.bezier-snap-trans,
  cornerbox : IM_MTX.cornerbox,
  bez-corner-box : IM_MTX.bez-corner-box,
  poly-corner-box : IM_MTX.poly-corner-box,
  circle : circle,
  ellipse : ellipse,
  line : line,
  make-text : make-text,
  make-text-font : make-text-font,
  triangle : triangle,
  right-triangle : right-triangle,
  isosceles-triangle : isosceles-triangle,
  triangle-sss : triangle-sss,
  triangle-ass : triangle-ass,
  triangle-sas : triangle-sas,
  triangle-ssa : triangle-ssa,
  triangle-aas : triangle-aas,
  triangle-asa : triangle-asa,
  triangle-saa : triangle-saa,
  square : square,
  rectangle : make-rectangle,
  rhombus : rhombus,
  star : star,
  radial-star : radial-star,
  star-sized : star-sized,
  star-polygon : star-polygon,
  regular-polygon : regular-polygon,
  empty-image : empty-image,
  overlay : overlay,
  overlay-pinhole : overlay-pinhole,
  overlay-align : overlay-align,
  overlay-offset : overlay-offset,
  overlay-align-offset : overlay-align-offset,
  overlay-xy : overlay-xy,
  underlay : underlay,
  underlay-pinhole : underlay-pinhole,
  underlay-align : underlay-align,
  underlay-offset : underlay-offset,
  underlay-align-offset : underlay-align-offset,
  underlay-xy : underlay-xy,
  beside : beside,
  beside-list : beside-list,
  beside-align : beside-align,
  beside-align-list : beside-align-list,
  above : above,
  above-list : above-list,
  above-align : above-align,
  above-align-list : above-align-list,
  empty-scene : empty-scene,
  colored-empty-scene : colored-empty-scene,
  place-image : place-image,
  place-images : place-images,
  place-image-align : place-image-align,
  place-images-align : place-images-align,
  frame : frame,
  add-line : add-line,
  add-curve : add-curve,
  add-line-to-scene : add-line-to-scene,
  add-curve-to-scene : add-curve-to-scene,
  polygon : make-polygon-from-points,
  add-polygon : add-polygon,
  add-polygon-to-scene : add-polygon-to-scene,
  draw-svg : draw-svg,
  draw-debug : draw-debug
} end
provide-types *


#import matrix, vector from shared-gdrive("matrices_3", "0ByJ_bK5RkycfSVZTRFd5QUpzaWc")
#import shared-gdrive("matrices_3", "0ByJ_bK5RkycfSVZTRFd5QUpzaWc") as M
#import shared-gdrive("XML", "0ByJ_bK5RkycfbE8zNF81SVBEcUE") as XML
#import shared-gdrive("image_datatypes", "0ByJ_bK5RkycfUURMNTk1X3JYd2s") as IM_D
#import shared-gdrive("image_auxiliary_datatypes", "0ByJ_bK5RkycfNEd0WGJ5eFc3RE0") as IM_AUX_DATA
#import shared-gdrive("image_matrix_helpers", "0ByJ_bK5RkycfWks5alRZNk42TVk") as IM_MTX
#import matrix, vector from "matrices.arr"
#import "matrices.arr" as M
#import "XML.arr" as XML
#import "image_datatypes.arr" as IM_D
#import "image_auxiliary_datatypes.arr" as IM_AUX_DATA
#import "image_matrix_helpers.arr" as IM_MTX
import matrix, vector from matrices
import matrices as M
import xml as XML
import image_datatypes as IM_D
import image_auxiliary_datatypes as IM_AUX_DATA
import image_matrix_helpers as IM_MTX
import Equal, NotEqual from equality
import image-dom as DOM


pi = 2 * num-asin(1)

fun to-radians(theta :: Number):
  doc: "Converts the given angle from degrees into radians"
  (theta * pi) * (1 / 180)
end

fun to-degrees(theta :: Number):
  doc: "Converts the given angle from radians into degrees"
  (theta * 180) / pi
end

#########################
# PYRET IMAGE DATATYPES #
#########################

### CONSTANTS
DEFAULT_OUTLINE_WIDTH = 2
OUTLINE_FIX_VEC = [vector: (1/2 * DEFAULT_OUTLINE_WIDTH), (1/2 * DEFAULT_OUTLINE_WIDTH)]

### USED PREDICATES



# greater-than-zero
# Predicate to make sure that the
#   given number is larger than 0.
fun greater-than-zero(n :: Number) -> Boolean:
  0 < n
end

# nonzero-nat
# Predicate to check if the
#   given number is a Natural
#   number greater than 0.
fun nonzero-nat(n :: Number) -> Boolean:
  (0 < n) and num-is-integer(n)
end

matrix2d = lam(m): m.rows == 2 end

### DATA DEFINITIONS

type Color = IM_D.Color
type Mode = IM_D.Mode
type X-Place = IM_D.X-Place
type Y-Place = IM_D.Y-Place

rgba-color = IM_D.rgba-color
rgb-color = IM_D.rgb-color
pen = IM_D.pen
style-dot = IM_D.style-dot
style-solid = IM_D.style-solid
style-long-dash = IM_D.style-long-dash
style-short-dash = IM_D.style-short-dash
style-dot-dash = IM_D.style-dot-dash
cap-round = IM_D.cap-round
cap-projecting = IM_D.cap-projecting
cap-butt = IM_D.cap-butt
join-bevel = IM_D.join-bevel
join-miter = IM_D.join-miter
join-round = IM_D.join-round
orangered = IM_D.orangered
tomato = IM_D.tomato
darkred = IM_D.darkred
red = IM_D.red
firebrick = IM_D.firebrick
crimson = IM_D.crimson
deeppink = IM_D.deeppink
maroon = IM_D.maroon
indianred = IM_D.indianred
mediumvioletred = IM_D.mediumvioletred
violetred = IM_D.violetred
lightcoral = IM_D.lightcoral
hotpink = IM_D.hotpink
palevioletred = IM_D.palevioletred
lightpink = IM_D.lightpink
rosybrown = IM_D.rosybrown
pink = IM_D.pink
orchid = IM_D.orchid
lavenderblush = IM_D.lavenderblush
snow = IM_D.snow
chocolate = IM_D.chocolate
saddlebrown = IM_D.saddlebrown
brown = IM_D.brown
darkorange = IM_D.darkorange
coral = IM_D.coral
sienna = IM_D.sienna
orange = IM_D.orange
salmon = IM_D.salmon
peru = IM_D.peru
darkgoldenrod = IM_D.darkgoldenrod
goldenrod = IM_D.goldenrod
sandybrown = IM_D.sandybrown
lightsalmon = IM_D.lightsalmon
darksalmon = IM_D.darksalmon
gold = IM_D.gold
yellow = IM_D.yellow
olive = IM_D.olive
burlywood = IM_D.burlywood
tan = IM_D.tan
navajowhite = IM_D.navajowhite
peachpuff = IM_D.peachpuff
khaki = IM_D.khaki
darkkhaki = IM_D.darkkhaki
moccasin = IM_D.moccasin
wheat = IM_D.wheat
bisque = IM_D.bisque
palegoldenrod = IM_D.palegoldenrod
blanchedalmond = IM_D.blanchedalmond
mediumgoldenrod = IM_D.mediumgoldenrod
papayawhip = IM_D.papayawhip
mistyrose = IM_D.mistyrose
lemonchiffon = IM_D.lemonchiffon
antiquewhite = IM_D.antiquewhite
cornsilk = IM_D.cornsilk
lightgoldenrodyellow = IM_D.lightgoldenrodyellow
oldlace = IM_D.oldlace
linen = IM_D.linen
lightyellow = IM_D.lightyellow
seashell = IM_D.seashell
beige = IM_D.beige
floralwhite = IM_D.floralwhite
ivory = IM_D.ivory
green = IM_D.green
lawngreen = IM_D.lawngreen
chartreuse = IM_D.chartreuse
greenyellow = IM_D.greenyellow
yellowgreen = IM_D.yellowgreen
mediumforestgreen = IM_D.mediumforestgreen
olivedrab = IM_D.olivedrab
darkolivegreen = IM_D.darkolivegreen
darkseagreen = IM_D.darkseagreen
lime = IM_D.lime
darkgreen = IM_D.darkgreen
limegreen = IM_D.limegreen
forestgreen = IM_D.forestgreen
springgreen = IM_D.springgreen
mediumspringgreen = IM_D.mediumspringgreen
seagreen = IM_D.seagreen
mediumseagreen = IM_D.mediumseagreen
aquamarine = IM_D.aquamarine
lightgreen = IM_D.lightgreen
palegreen = IM_D.palegreen
mediumaquamarine = IM_D.mediumaquamarine
turquoise = IM_D.turquoise
lightseagreen = IM_D.lightseagreen
mediumturquoise = IM_D.mediumturquoise
honeydew = IM_D.honeydew
mintcream = IM_D.mintcream
royalblue = IM_D.royalblue
dodgerblue = IM_D.dodgerblue
deepskyblue = IM_D.deepskyblue
cornflowerblue = IM_D.cornflowerblue
steelblue = IM_D.steelblue
lightskyblue = IM_D.lightskyblue
darkturquoise = IM_D.darkturquoise
cyan = IM_D.cyan
aqua = IM_D.aqua
darkcyan = IM_D.darkcyan
teal = IM_D.teal
skyblue = IM_D.skyblue
cadetblue = IM_D.cadetblue
darkslategray = IM_D.darkslategray
lightslategray = IM_D.lightslategray
slategray = IM_D.slategray
lightsteelblue = IM_D.lightsteelblue
lightblue = IM_D.lightblue
powderblue = IM_D.powderblue
paleturquoise = IM_D.paleturquoise
lightcyan = IM_D.lightcyan
aliceblue = IM_D.aliceblue
azure = IM_D.azure
mediumblue = IM_D.mediumblue
darkblue = IM_D.darkblue
midnightblue = IM_D.midnightblue
navy = IM_D.navy
blue = IM_D.blue
indigo = IM_D.indigo
blueviolet = IM_D.blueviolet
mediumslateblue = IM_D.mediumslateblue
slateblue = IM_D.slateblue
purple = IM_D.purple
darkslateblue = IM_D.darkslateblue
darkviolet = IM_D.darkviolet
darkorchid = IM_D.darkorchid
mediumpurple = IM_D.mediumpurple
mediumorchid = IM_D.mediumorchid
magenta = IM_D.magenta
fuchsia = IM_D.fuchsia
darkmagenta = IM_D.darkmagenta
violet = IM_D.violet
plum = IM_D.plum
lavender = IM_D.lavender
thistle = IM_D.thistle
ghostwhite = IM_D.ghostwhite
white = IM_D.white
whitesmoke = IM_D.whitesmoke
gainsboro = IM_D.gainsboro
lightgray = IM_D.lightgray
silver = IM_D.silver
gray = IM_D.gray
grey = IM_D.grey
darkgray = IM_D.darkgray
dimgray = IM_D.dimgray
black = IM_D.black
outline = IM_D.outline
solid = IM_D.solid
x-left = IM_D.x-left
x-center = IM_D.x-center
x-right = IM_D.x-right
y-top = IM_D.y-top
y-center = IM_D.y-center
y-bottom = IM_D.y-bottom

type Position = IM_AUX_DATA.Position
type Box = IM_AUX_DATA.Box
type Interval = IM_AUX_DATA.Interval

posn = IM_AUX_DATA.posn
explicit-posn = IM_AUX_DATA.explicit-posn
is-explicit-posn = IM_AUX_DATA.is-explicit-posn
box = IM_AUX_DATA.box
ivl = IM_AUX_DATA.ivl

vector-sub = IM_MTX.vector-sub
points-bounding-box = IM_MTX.points-bounding-box
list-of-points-bounding-box = IM_MTX.list-of-points-bounding-box
mtx-center = IM_MTX.mtx-center
translate = IM_MTX.translate
translate-posn = IM_MTX.translate-posn
trans-mtx = IM_MTX.trans-mtx
homogeneous-transform = IM_MTX.homogeneous-transform
transform-posn = IM_MTX.transform-posn
transform-posn-about = IM_MTX.transform-posn-about
affine-transform-matrix = IM_MTX.affine-transform-matrix
matrix-to-posns = IM_MTX.matrix-to-posns
matrices-to-posns = IM_MTX.matrices-to-posns
bezier-box = IM_MTX.bezier-box
bezier-snap-trans = IM_MTX.bezier-snap-trans

type CornerBox = IM_MTX.CornerBox
cornerbox = IM_MTX.cornerbox
bez-corner-box = IM_MTX.bez-corner-box
poly-corner-box = IM_MTX.poly-corner-box

fun reorder-step(lst :: List, step :: Number%(nonzero-nat)):
  doc: "Reorders the given list using the given step size"
  len = lst.length()
  new-idx = lam(i): num-modulo(i * step, len) end
  var ret-lst = empty
  for each(i from range(1, len + 1).reverse()):
    ret-lst := link(lst.get(new-idx(len - i)), ret-lst)
  end
  ret-lst
end

# Transformation Matrices Definitions

fun rotation-matrix(theta-deg :: Number) -> M.Matrix:
  doc: "Returns a rotation matrix for the given counterclockwise angle"
  theta = -1 * to-radians(theta-deg)
  [matrix(2,2): num-cos(theta), (-1 * num-sin(theta)),
    num-sin(theta), num-cos(theta)]
end

fun scale-xy-matrix(xk :: Number, yk :: Number) -> M.Matrix:
  doc: "Returns an xy-scaling matrix for the given scales"
  [matrix(2,2): xk, 0, 0, yk]
end

fun scale-x-matrix(k :: Number) -> M.Matrix:
  doc: "Returns an x-scaling matrix for the given scale"
  scale-xy-matrix(k, 1)
end

fun scale-y-matrix(k :: Number) -> M.Matrix:
  doc: "Returns a y-scaling matrix for the given scale"
  scale-xy-matrix(1, k)
end

fun scale-matrix(k :: Number) -> M.Matrix:
  doc: "Returns a scaling matrix for the given amount"
  scale-xy-matrix(k, k)
end


flip-horiz-matrix = [matrix(2,2): -1, 0, 0, 1]

flip-vert-matrix = [matrix(2,2): 1, 0, 0, -1]

#Datatype helpers

fun snap-row-trans(img :: List<List<Number>>) -> M.Vector:
  doc: "Returns the vector needed to snap the given list of points to the bounds of the first quadrant"
  min-x = img.first.map(num-exact).sort().first
  min-y = img.get(1).map(num-exact).sort().first
  trans-x = if (min-x < 0):
    num-abs(min-x)
  else:
    -1 * min-x
  end
  trans-y = if (min-y < 0):
    num-abs(min-y)
  else:
    -1 * min-y
  end
  [vector: trans-x, trans-y]
end

fun new-box(i1 :: Image, x :: Number, y :: Number, i2 :: Image, i1-pinhole :: Position) -> Box:
  doc: "Returns the new box of the first image placed on the second at the given position"
  top-shift-x = x - (i1-pinhole.x)
  top-shift-y = y - (i1-pinhole.y)
  i1.translate([vector: top-shift-x, top-shift-y]).cornerbox().join(i2.cornerbox()).to-box()
end

fun new-svg-size(i1 :: Image, x :: Number, y :: Number, i2 :: Image, i1-pinhole :: Position) -> Box:
  doc: "Returns the new svg canvas size of the first image placed on the second at the given position"
  top-box = i1.get-box()
  top-svg = i1.svg-size()
  top-shift-x = x + ((top-box.width / 2) - i1-pinhole.x)
  top-shift-y = y + ((top-box.height / 2) - i1-pinhole.y)
  top-x = ivl(0,(top-svg.width)).shift(top-shift-x)
  top-y = ivl(0,(top-svg.height)).shift(top-shift-y)
  bottom-svg = i2.svg-size()
  box-x = ivl(0,bottom-svg.width).comb(top-x).len()
  box-y = ivl(0,bottom-svg.height).comb(top-y).len()
  box(box-x,box-y)
end

fun clip-box(i1 :: Image, x :: Number, y :: Number, i2 :: Image, i1-pinhole :: Position) -> Box:
  doc: "Returns the size of the first image's box (placed at the given position) clipped to the second's"
  top-box = i1.get-box()
  top-shift-x = x + ((top-box.width / 2) - i1-pinhole.x)
  top-shift-y = y + ((top-box.height / 2) - i1-pinhole.y)
  top-x = ivl((-1 * (top-box.width / 2)),(top-box.width / 2)).shift(top-shift-x)
  top-y = ivl((-1 * (top-box.height / 2)),(top-box.height / 2)).shift(top-shift-y)
  bottom-box = i2.get-box()
  box-x = ivl(0,bottom-box.width).intersect(top-x).len()
  box-y = ivl(0,bottom-box.height).intersect(top-y).len()
  box(box-x,box-y)
end

# Needed inside of the data definition, so placing here
# with polygon-maker parameter subverts scoping problems
fun rectangle(polygon-maker,
              width  :: Number%(greater-than-zero),
              height :: Number%(greater-than-zero),
              mode   :: Mode,
              color  :: Color) :
  polygon-maker([matrix(2,4):  0, 0, width, width,
      0, height, height, 0], mode, color, posn((width / 2), (height / 2))).snap-axes()
end

fun calc-compound-vector(top-img, bot-img, bot-center, at):
  # print('')
  # print('[calc-compound-vector start]')
  basis = bot-img.coord-zero()
  true-at = posn(at.x + basis.x, at.y + basis.y)
  tpin = top-img.get-center()
  
  # print('basis   : ' + torepr(basis))
  # print('true-at : ' + torepr(true-at))
  # print('tpin    : ' + torepr(tpin))
  # print('[calc-compound-vector end]')
  [list: true-at.x - tpin.x, true-at.y - tpin.y]
end
  

# The Image Data Type

# IMAGE DATATYPE LAYOUT:
# - Primitives (circle, star, square, etc.)
#    + Same as 2htdp library
# - Compound Image
#    + A Binary Tree datatype which represents
#        one image on top of another, centered
#        at the given point
# - Orthoganally Transformed Images (rotation, reflection)
#    + Represents an image with a size-preserving
#        transformation



data Image:
  # text()
  # Represents the given string
  #   of text, using the given
  #   font size and color
  | text(string :: String,
         size   :: Number%(greater-than-zero),
         color  :: Color,
      center   :: Position) with:
      cornerbox(self):
        DOM.text-svg-bounding-box(self.string, "font-size:" + num-tostring(self.size) + "px;",
            self.center.x, self.center.y, "")
      end
    
  # text-font()
  # Represents the given string
  #   of text with the given font
  #   specification
  | text-font(string      :: String,
              size        :: Number%(greater-than-zero),
              color       :: Color,
              font-face   :: String, #TODO: Font Face datatype?
              font-family :: String, #TODO: Font Family datatype?
              style       :: String,
              weight      :: String,
              underline   :: Boolean,
      center   :: Position)
  | polygon(matrix :: M.Matrix,
      mode :: Mode,
      color :: Color,
      center :: Position
      ) with:
    to-matrix(self): self.matrix end,
    get-box(self): 
      cases(Mode) self.mode:
        | solid => points-bounding-box(self.matrix)
        | outline =>
          base-box = points-bounding-box(self.matrix)
          base-box
          # By default, half of the outline is cut off
          #box(base-box.width + DEFAULT_OUTLINE_WIDTH, base-box.height + DEFAULT_OUTLINE_WIDTH)
      end 
    end,
    
    translate(self, v :: M.Vector) -> Image: 
      polygon(translate(self.matrix,v),self.mode,self.color,translate-posn(self.center,v))
    end,
    
    transform(self, mtx :: M.Matrix) -> Image:
      polygon(homogeneous-transform(mtx,self.matrix),
        self.mode,self.color,transform-posn(mtx,self.center))
    end,
    
    affine-transform-about(self, transformation :: M.Matrix%(matrix2d), abt :: Position) -> Image:
      doc: "Performs an affine transformation of the image about the given point"
      self.translate([vector: (-1 * abt.x), (-1 * abt.y)] ).transform(transformation).translate([vector: abt.x, abt.y])
    end,
    
    affine-transform(self, transformation :: M.Matrix%(matrix2d)) -> Image:
      self.affine-transform-about(transformation,self.get-center())
    end,
    
    snap-vec(self):
      snap-row-trans(self.matrix.to-lists())
    end,
    
    snap-axes(self):
      cases(Mode) self.mode:
        | solid => self.translate(snap-row-trans(self.matrix.to-lists()))
        | outline => self.translate(snap-row-trans(self.matrix.to-lists()))#.translate( OUTLINE_FIX_VEC)
      end
    end,
    
    new-color(self, k :: Color) -> Image:
      polygon(self.matrix, self.mode, k, self.center)
    end,
    
    scale-pen(self, k :: Number%(num-is-non-negative)) -> Image:
      polygon(self.matrix, self.mode, self.color.scale(k), self.center)
    end,
    
    mtx-list(self) -> List<List<Number>>:
      self.matrix.to-lists()
    end,
    
    svg-size(self) -> Box:
      cornerbox(posn(0,0),self.cornerbox().bottom-right).to-box()
    end,
    
    put-pinhole(self, phx :: Number, phy :: Number) -> Image:
      polygon(self.matrix, self.mode, self.color, explicit-posn(phx,phy))
    end,
    
    clear-pinhole(self) -> Image:
      sbb = self.get-box()
      polygon(self.matrix, self.mode, self.color, posn(sbb.width / 2, sbb.height / 2))
    end,
    
    cornerbox(self) -> CornerBox:
      poly-corner-box(self.mtx-list())
    end
    
#    equalTo(self, a :: Image%(is-polygon), eq):
#      if (self.matrix == a.matrix):
#        if (self.mode == a.mode):
#          if (self.color == a.color):
#            if (self.center == a.center):
#              Equal
#            else:
#              NotEqual("Image pinholes differ")
#            end
#          else:
#            NotEqual("Image colors differ")
#          end
#        else:
#          NotEqual("Image modes differ")
#        end
#      else:
#        NotEqual("Images are of different shapes")
#      end
#    end,
    
#    _equals(self, a :: Image %(is-polygon), eq):
#      self.equalTo(a,eq)
#    end
          
    
  | bezier-shape(matrix :: M.Matrix,
      mode :: Mode,
      color :: Color,
      center :: Position
      ) with:
    to-matrix(self): self.matrix end,
    get-box(self): 
	  self.cornerbox().to-box()
    end,
    
    translate(self, v :: M.Vector) -> Image: 
      bezier-shape(translate(self.matrix,v),self.mode,self.color,translate-posn(self.center,v))
    end,
    
    transform(self, mtx :: M.Matrix) -> Image:
      bezier-shape(homogeneous-transform(mtx,self.matrix),
        self.mode,self.color,transform-posn(mtx,self.center))
    end,
    
    affine-transform-about(self, transformation :: M.Matrix%(matrix2d), abt :: Position) -> Image:
      doc: "Performs an affine transformation of the image about the given point"
      self.translate([vector: (-1 * abt.x), (-1 * abt.y)] ).transform(transformation).translate([vector: abt.x, abt.y])
    end,
    
    affine-transform(self, transformation :: M.Matrix%(matrix2d)) -> Image:
      self.affine-transform-about(transformation,self.get-center())
    end,
    
    snap-vec(self):
      bezier-snap-trans(matrix-to-posns(self.matrix))
    end,
    
    snap-axes(self):
      cases(Mode) self.mode:
        | solid => self.translate(bezier-snap-trans(matrix-to-posns(self.matrix)))
        | outline => self.translate(bezier-snap-trans(matrix-to-posns(self.matrix)))#.translate( OUTLINE_FIX_VEC)
      end
    end,
    
    new-color(self, k :: Color) -> Image:
      bezier-shape(self.matrix, self.mode, k, self.center)
    end,
    
    scale-pen(self, k :: Number%(num-is-non-negative)) -> Image:
      bezier-shape(self.matrix, self.mode, self.color.scale(k), self.center)
    end,
    
    mtx-list(self) -> List<List<Number>>:
      self.matrix.to-lists()
    end,
    
    svg-size(self) -> Box:
      cornerbox(posn(0,0),self.cornerbox().bottom-right).to-box()
    end,
    
    put-pinhole(self, phx :: Number, phy :: Number) -> Image:
      bezier-shape(self.matrix, self.mode, self.color, explicit-posn(phx,phy))
    end,
    
    clear-pinhole(self) -> Image:
      sbb = self.get-box()
      bezier-shape(self.matrix, self.mode, self.color, posn(sbb.width / 2, sbb.height / 2))
    end,
    
    cornerbox(self) -> CornerBox:
      bez-corner-box(matrix-to-posns(self.matrix))
    end
    
    
  | compound-image(top    :: Image,
                   at     :: Position,
                   bottom :: Image,
      center   :: Position
      ) with:
    get-box(self):
      new-box(self.top,self.at.x,self.at.y,self.bottom,self.top.get-center())
    end,
    
    translate(self, v :: M.Vector) -> Image: 
      compound-image(self.top.translate(v), self.at, self.bottom.translate(v), translate-posn(self.center, v))
    end,
    
    #transform(self, mtx :: M.Matrix) -> Image:
      
    #end,
    
    affine-transform(self, transformation :: M.Matrix%(matrix2d)) -> Image:
      current-center = self.get-center()
      bottom-center = self.bottom.get-center()
      ti = self.top.affine-transform-about(transformation,current-center)
      bi = self.bottom.affine-transform-about(transformation,current-center)
      ti-snap = ti.snap-axes()
      bi-snap = bi.snap-axes()
      # Convert self.at to global coordinates and transform
      bottom-zero = self.bottom.coord-zero()
      true-at = posn(bottom-zero.x + self.at.x, bottom-zero.y + self.at.y)
      trans-at = transform-posn-about(transformation, true-at, current-center)
      # Use the newly transformed bottom to relativize the transformed self.at
      bi-zero = bi.coord-zero()
      #bi-center = bi.get-center()
      new-at = posn(trans-at.x - bi-zero.x, trans-at.y - bi-zero.y)
      ti-vec = ti.snap-vec()
      bi-vec = bi.snap-vec()
      # Do same transformations on pinhole
      #pin-off = posn(self.center.x - current-center.x, self.center.y - current-center.y)
      #trans-off = transform-posn-about(transformation, self.center, current-center)
      #true-pinhole = posn(bottom-zero.x + self.center.x, bottom-zero.y + self.center.y)
      #trans-pinhole = transform-posn-about(transformation, true-pinhole, current-center)
      #new-pin = posn(trans-pinhole.x - bi-zero.x, trans-pinhole.y - bi-zero.y)
      # svec = bi.snap-vec()
      # svec-pin = posn(bi-vec.first, bi-vec.rest.first)
      offset = posn(self.center.x - current-center.x, self.center.y - current-center.y)
      trans-off = transform-posn(transformation, offset)
      # plus-svec = posn(svec-pin.x + self.center.x, svec-pin.y + self.center.y)
      dvec = calc-compound-vector(ti-snap, bi-snap, bi-snap.get-center(), new-at)
      trans-topx-p = dvec.first  >= 0 
      trans-topy-p = dvec.get(1) >= 0
      dtx = if trans-topx-p: dvec.first  else: 0 end
      dty = if trans-topy-p: dvec.get(1) else: 0 end
      dbx = if trans-topx-p: 0 else: -1 * dvec.first  end
      dby = if trans-topy-p: 0 else: -1 * dvec.get(1) end

      #simple-trans = transform-posn(transformation, self.center)
      top-trans-box = ti-snap.cornerbox().translate(dtx, dty)
      transformed-box = top-trans-box.join(bi-snap.cornerbox().translate(dbx, dby))
      tb-center = transformed-box.get-center()
      # new-pin = transformed-box.get-center()
      new-pin = self.make-pinhole(trans-off.x + tb-center.x, trans-off.y + tb-center.y)
      #new-pin = trans-off
      #new-pin = posn(self.center.x + svec.first, self.center.y + svec.rest.first)
      #new-pin = posn(svec-pin.x + dtx + dbx, svec-pin.y + dty + dby)
      # new-pin = plus-svec
      fun smart-str(l :: List<Number>):
        "[list: " + l.map(lam(n): num-to-string-digits(n, 5) end).join-str(", ") + "]"
      end
      #new-pin = transform-posn-about(transformation, self.center, current-center)
      # print('')
      # print('[affine-transform start]')
      # print('bottom-zero    : ' + torepr(bottom-zero))
      # print('current-center : ' + torepr(current-center))
      # print('bottom-center  : ' + torepr(bottom-center))
      # print('at             : ' + torepr(self.at))
      # print('center         : ' + torepr(self.center))
      # print('true-at        : ' + torepr(true-at))
      # print('trans-at       : ' + torepr(trans-at))
      # print('bi-zero        : ' + torepr(bi-zero))
      # print('tb-center      : ' + torepr(tb-center))
      # print('new-at         : ' + torepr(new-at))
      # print('offset         : ' + torepr(offset))
      # print('trans-off      : ' + torepr(trans-off))
      # #print('dtx            : ' + torepr(dtx))
      # #print('dty            : ' + torepr(dty))
      # #print('dbx            : ' + torepr(dbx))
      # #print('dby            : ' + torepr(dby))
      # #print('plus-svec      : ' + torepr(plus-svec))
      # print('new-pin        : ' + torepr(new-pin))
      # #print('simple-trans   : ' + torepr(simple-trans))
      # print('ti.snap-vec()  : ' + smart-str(ti-vec))
      # print('bi.snap-vec()  : ' + smart-str(bi-vec))
      # print('[affine-transform end]')
      # print('')
      
      #ob = self.get-box()
      #old-bottom = self.bottom.get-box()
      #new-bottom = bi.get-box()
      #relpos = posn(self.center.x / ob.width, self.center.y / ob.height)
      #new-at = posn((self.at.x * new-bottom.width) / old-bottom.width, (self.at.y * new-bottom.height) / old-bottom.height)
      #nb = new-box(ti,new-at.x, new-at.y,bi, ti.center)
      #new-c = posn(relpos.x * nb.width, relpos.y * nb.height)
      #new-c = transform-posn-about(transformation, self.center, self.center)
      #new-at = posn(self.at.x + (new-c.x - self.center.x),self.at.y + (new-c.y - self.center.y))
      compound-image(ti-snap, new-at, bi-snap, new-pin)
      
      #compound-image(self.top.translate([vector: (-1 * self.center.x), (-1 * self.center.y)] ).affine-transform(transformation).translate([vector: self.center.x, self.center.y]), self.at,
       # self.bottom.translate([vector: (-1 * self.center.x), (-1 * self.center.y)] ).affine-transform(transformation).translate([vector: self.center.x, self.center.y]),self.center)
    end,
    
    snap-vec(self):
      t-trans = cases(Image) self.top:
        | polygon(_,_,_,_) => 
          if (self.top.mode == solid):
            snap-row-trans(self.top.mtx-list())
          else:
            snap-row-trans(self.top.mtx-list())
            #vector-sub(snap-row-trans(self.top.mtx-list()), OUTLINE_FIX_VEC)
          end
        | bezier-shape(_,_,_,_) =>
          if (self.top.mode == solid):
            bezier-snap-trans(matrix-to-posns(self.top.matrix))
          else:
            bezier-snap-trans(matrix-to-posns(self.top.matrix))
            #vector-sub(bezier-snap-trans(matrix-to-posns(self.top.matrix)), OUTLINE_FIX_VEC)
          end
        | compound-image(_,_,_,_) =>
          self.top.snap-vec()
        | clipped-image(_,_) => self.top.snap-vec()
        | else => raise("Not yet implemented")
      end
      b-trans = cases(Image) self.bottom:
        | polygon(_,_,_,_) => 
          if (self.bottom.mode == solid):
            snap-row-trans(self.bottom.mtx-list())
          else:
            snap-row-trans(self.bottom.mtx-list())
            #vector-sub(snap-row-trans(self.bottom.mtx-list()), OUTLINE_FIX_VEC)
          end
        | bezier-shape(_,_,_,_) =>
          if (self.bottom.mode == solid):
            bezier-snap-trans(matrix-to-posns(self.bottom.matrix))
          else:
            bezier-snap-trans(matrix-to-posns(self.bottom.matrix))
            #vector-sub(bezier-snap-trans(matrix-to-posns(self.bottom.matrix)), OUTLINE_FIX_VEC)
          end
        | compound-image(_,_,_,_) =>
          self.bottom.snap-vec()
        | clipped-image(_,_) => self.bottom.snap-vec()
        | else => raise("Not yet implemented")
      end
      [vector: num-max(t-trans.get(0),b-trans.get(0)), num-max(t-trans.get(1),b-trans.get(1))]
    end,
    
    snap-axes(self):
      #print('snap-axes(): snap-vec: ' + torepr(self.snap-vec()))
      self.translate(self.snap-vec())
    end,
    
    new-color(self, k :: Color) -> Image:
      compound-image(self.top.new-color(k), self.at, self.bottom.new-color(k), self.center)
    end,
    
    scale-pen(self, k :: Number%(num-is-non-negative)) -> Image:
      compound-image(self.top.scale-pen(k), self.at, self.bottom.scale-pen(k), self.center)
    end,
    
    mtx-list(self) -> List<List<Number>>:
      t = self.top.mtx-list()
      b = self.bottom.mtx-list()
      [list: t.first.append(b.first), t.get(1).append(b.get(1))]
    end,
    
    svg-size(self) -> Box:
      #if (is-clipped-image(self.top)):
      #  new-svg-size(self.top,self.at.x,self.at.y,self.bottom,self.top.pair.center)
      #else:
      #  new-svg-size(self.top,self.at.x,self.at.y,self.bottom, self.top.center)
      #end
      self.get-box() # Looking at the code for new-box(), it already works
    end,
    
    put-pinhole(self, phx :: Number, phy :: Number) -> Image:
      compound-image(self.top, self.at, self.bottom, explicit-posn(phx,phy))
    end,
    
    clear-pinhole(self) -> Image:
      sbb = self.get-box()
      compound-image(self.top, self.at, self.bottom, posn(sbb.width / 2, sbb.height / 2))
    end,
    
    cornerbox(self) -> CornerBox:
      # print('\n[cornerbox() start]')
      dvec = calc-compound-vector(self.top, self.bottom, self.bottom.get-center(), self.at)
      # print('              dvec: ' + torepr(dvec))
      trans-topx-p = dvec.first  >= 0 
      trans-topy-p = dvec.get(1) >= 0
      # print('      trans-topx-p: ' + torepr(trans-topx-p))
      # print('      trans-topy-p: ' + torepr(trans-topy-p))
      dtx = if trans-topx-p: dvec.first  else: 0 end
      dty = if trans-topy-p: dvec.get(1) else: 0 end
      dbx = if trans-topx-p: 0 else: -1 * dvec.first  end
      dby = if trans-topy-p: 0 else: -1 * dvec.get(1) end
      # print('               dtx: ' + torepr(dtx))
      # print('               dty: ' + torepr(dty))
      # print('               dbx: ' + torepr(dbx))
      # print('               dby: ' + torepr(dby))
      trans-box = self.top.cornerbox().translate(dtx, dty)
      # print('pre-trans (top)   : ' + torepr(self.top.cornerbox()))
      # print('trans-box (top)   : ' + torepr(trans-box))
      # print('pre-trans (bottom): ' + torepr(self.bottom.cornerbox()))
      # print('trans-box (bottom): ' + torepr(self.bottom.cornerbox().translate(dbx, dby)))
      # print('[cornerbox() end]')
      # print('')
      trans-box.join(self.bottom.cornerbox().translate(dbx, dby))
    end
    
    
    # Represents an image where the top of the compound image is clipped to the bottom
  | clipped-image(pair :: Image%(is-compound-image),
      hidden-mask :: Boolean) #If true, the bottom image is simply used as a clipping mask,
                            # as opposed to being a background 
                            # which the top is clipped to
    with:
    get-box(self):
      self.cornerbox().to-box()
      #if self.hidden-mask:
      #  clip-box(self.pair.top, self.pair.at.x, self.pair.at.y, self.pair.bottom, self.pair.top.center)
      #else:
      #  self.pair.bottom.get-box()
      #end
    end,
    
    translate(self, v :: M.Vector) -> Image:
      clipped-image(self.pair.translate(v), self.hidden-mask)
    end,
    
    affine-transform(self, transformation :: M.Matrix%(matrix2d)) -> Image:
      clipped-image(self.pair.affine-transform(transformation),self.hidden-mask)
    end,
    
    snap-vec(self) -> M.Vector:
      self.pair.snap-vec()
    end,
    
    snap-axes(self) -> Image:
      clipped-image(self.pair.snap-axes(),self.hidden-mask)
    end,
    
    new-color(self, k :: Color) -> Image:
      clipped-image(self.pair.new-color(k),self.hidden-mask)
    end,
    
    scale-pen(self, k :: Number%(num-is-non-negative)) -> Image:
      clipped-image(self.pair.scale-pen(k), self.hidden-mask)
    end,
    
    hide-mask(self) -> Image:
      clipped-image(self.pair,true)
    end,
    
    show-mask(self) -> Image:
      clipped-image(self.pair,false)
    end,
    
    mtx-list(self) -> List<List<Number>>:
      self.pair.bottom.mtx-list()
    end,
    
    svg-size(self) -> Box:
      self.pair.bottom.svg-size()
    end,
    
    put-pinhole(self, phx :: Number, phy :: Number) -> Image:
      clipped-image(self.pair.put-pinhole(phx,phy), self.hidden-mask)
    end,
    
    clear-pinhole(self) -> Image:
      new-c = self.pair.bottom.clear-pinhole().center
      clipped-image(compound-image(self.pair.top, self.pair.at, self.pair.bottom, new-c), self.hidden-mask)
    end,
    
    cornerbox(self) -> CornerBox:
      self.pair.bottom.cornerbox()
      # if self.hidden-mask:
        # dvec = calc-compound-vector(self.pair.top, self.pair.bottom, self.pair.bottom.get-pinhole(), self.pair.at)
        # #trans-topx-p = dvec.first  >= 0 
        # #trans-topy-p = dvec.get(1) >= 0
        # #dtx = if trans-topx-p: dvec.first  else: 0 end
        # #dty = if trans-topy-p: dvec.get(0) else: 0 end
        # #dbx = if trans-topx-p: 0 else: -1 * dvec.first  end
        # #dby = if trans-topy-p: 0 else: -1 * dvec.get(1) end
        # trans-box = self.pair.top.cornerbox().translate(dvec.first, dvec.get(1))
        # trans-box.intersect(self.pair.bottom.cornerbox())
        # #self.pair.top.cornerbox().intersect(self.pair.bottom.cornerbox())
      # else:
        # self.pair.bottom.cornerbox()
      # end
    end
    
sharing:
    
  flip-horizontal(self):
    self.affine-transform(flip-horiz-matrix).snap-axes()
  end,
  flip-vertical(self):
    self.affine-transform(flip-vert-matrix).snap-axes()
  end,
  scale-x(self, k :: Number):
    self.affine-transform(scale-x-matrix(k)).snap-axes()
  end,
  scale-y(self, k :: Number):
    self.affine-transform(scale-y-matrix(k)).snap-axes()
  end,
  scale-xy(self, xk :: Number, yk :: Number):
    self.affine-transform(scale-xy-matrix(xk,yk)).snap-axes()
  end,
  scale(self, k :: Number):
    self.affine-transform(scale-matrix(k)).snap-axes().scale-pen(k)
  end,
  rotate(self, theta :: Number):
    self.affine-transform(rotation-matrix(theta)).snap-axes()
  end,
  crop(self, x :: Number, y :: Number, width :: Number, height :: Number):
    doc: "Crops the image to a rectangle of the given width and height and its top-left corner at the given (x,y) position"
    self-bb = self.get-box()
    at = posn((self-bb.width / 2) - x, (self-bb.height / 2) - y)
    clipped-image(compound-image(self,at, rectangle(polygon, width,height,outline,black),self.make-pinhole((width / 2), (height / 2))),true)
  end,
  crop-align(self, xp :: X-Place, yp :: Y-Place, width :: Number, height :: Number):
    doc: "Crops the image to a rectangle of the given width and height placed at the given alignment"
    self-bb = self.get-box()
    at = posn(cases(X-Place) xp:
        | x-left => (self-bb.width / 2)
        | x-center => (width / 2)
        | x-right => (width) - (self-bb.width / 2)
      end, cases(Y-Place) yp:
        | y-top => (self-bb.height / 2)
        | y-center => (height / 2)
        | y-bottom => (height) - (self-bb.height / 2)
      end)
    clipped-image(compound-image(self, at, rectangle(polygon, width,height,outline,black),self.make-pinhole(width / 2, height / 2)), true)
  end,
  width(self) -> Number:
    doc: "Returns the image's width"
    self.get-box().width
  end,
  height(self) -> Number:
    doc: "Returns the image's height"
    self.get-box().height
  end,
  coord-zero(self) -> Position:
    doc: "Returns the position of the top-left corner of the image"
    self.cornerbox().top-left
  end,
  get-center(self) -> Position:
    doc: "Returns the center coordinate of this image"
    self.cornerbox().get-center()
  end,
  get-pinhole(self) -> Position:
    doc: "Returns the point about which this image is transformed"
    if is-clipped-image(self):
      self.pair.get-pinhole()
    else:
      self.center
    end
  end,
  pinhole-x(self):
    pin = self.get-pinhole()
    if is-explicit-posn(pin):
      pin.x
    else:
      false
    end
  end,
  pinhole-y(self):
    pin = self.get-pinhole()
    if is-explicit-posn(pin):
      pin.y
    else:
      false
    end
  end,
  center-pinhole(self) -> Image:
    center = self.get-center()
    self.put-pinhole(center.x, center.y)
  end,
  make-pinhole(self, x :: Number, y :: Number) -> Position:
    if is-explicit-posn(self.get-pinhole()):
      explicit-posn(x, y)
    else:
      posn(x, y)
    end
  end
#  end,
#  _torepr(self, shadow torepr):
#    torepr(draw-svg(self))
#  end

end

#####################
## IMAGE CONSTRUCTORS
#####################

fun circle(radius :: Number, mode :: Mode, color :: Color):
  circ-const = 4/3 * (num-sqrt(2) - 1)
  r = radius
  rc = r * circ-const
  cx = radius
  cy = radius
  arc1 = [matrix(2,4): 0, rc, r, r,
    (-1 * r), (-1 * r), (-1 * rc), 0]
  arc2 = [matrix(2,3):  r, rc, 0,
    rc, r, r]
  arc3 = [matrix(2,3):  (-1 * rc), (-1 * r), (-1 * r),
    r, rc, 0]
  arc4 = [matrix(2,3):  (-1 * r), (-1 * rc), 0,
    (-1 * rc), (-1 * r), (-1 * r)]
  
  mtx = translate(arc1.augment(arc2).augment(arc3).augment(arc4),[vector: cx, cy])
  bezier-shape(mtx, mode, color, posn(radius, radius)).snap-axes()
end

fun ellipse(width  :: Number%(greater-than-zero),
    height :: Number%(greater-than-zero),
    mode   :: Mode,
    color  :: Color) :
  circ-const = 4/3 * (num-sqrt(2) - 1)
  rx = width / 2
  ry = height / 2
  rxc = rx * circ-const
  ryc = ry * circ-const
  cx = rx
  cy = ry
  arc1 = [matrix(2,4): 0, rxc, rx, rx,
    (-1 * ry), (-1 * ry), (-1 * ryc), 0]
  arc2 = [matrix(2,3):  rx, rxc, 0,
    ryc, ry, ry]
  arc3 = [matrix(2,3):  (-1 * rxc), (-1 * rx), (-1 * rx),
    ry, ryc, 0]
  arc4 = [matrix(2,3):  (-1 * rx), (-1 * rxc), 0,
    (-1 * ryc), (-1 * ry), (-1 * ry)]
      
  mtx = translate(arc1.augment(arc2).augment(arc3).augment(arc4),[vector: cx, cy])
  bezier-shape(mtx, mode, color, posn(rx, ry)).snap-axes()
end
# line()
# Represents a line going from point
#   (0,0) to point (x,y) of the given color
fun line(x     :: Number,
    y     :: Number,
    color :: Color) :
  polygon([matrix(2,2): 0, x, 0, y], outline, color, posn(x / 2, y / 2)).snap-axes()
end

# Only called internally
# (Implemented using angle/pull definition found
#  in Barland, Findler, and Flatt 2010
#  ["The Design of a Functional Image Library"] and
#  curve-segment->path in gui-lib/mrlib/image-core.rkt)
fun curve(angle1, pull1, x, y, angle2, pull2, pen-or-color):
  length = num-sqrt(num-sqr(x) + num-sqr(y))
  theta1 = to-radians(angle1)
  theta2 = to-radians(angle2)
  handle1-x = pull1 * num-cos(theta1) * length
  handle1-y = pull1 * num-sin(theta1) * length
  handle2-x = x - (pull2 * num-cos(theta2) * length)
  handle2-y = y - (pull2 * num-sin(theta2) * length)
  pts = [matrix(2,4): 0, handle1-x, handle2-x, x, 0, handle1-y, handle2-y, y]
  # print('pull1     : ' + torepr(pull1))
  # print('pull2     : ' + torepr(pull2))
  # print('x         : ' + torepr(x))
  # print('y         : ' + torepr(y))
  # print('theta1    : ' + torepr(theta1))
  # print('theta2    : ' + torepr(theta2))
  # print('handle1-x : ' + torepr(handle1-x))
  # print('handle1-y : ' + torepr(handle1-y))
  # print('handle2-x : ' + torepr(handle2-x))
  # print('handle2-y : ' + torepr(handle2-y))
  # print('pts       : ' + torepr(pts))
  cb = IM_MTX.cubic-bezier-bounding-box(posn(0, 0), posn(handle1-x, handle1-y), 
    posn(handle2-x, handle2-y), posn(x, y))
  bezier-shape(pts, outline, pen-or-color, cb.get-center())
end
  
# text()
# Represents the given string
#   of text, using the given
#   font size and color
fun make-text(string :: String,
    size   :: Number%(greater-than-zero),
    color  :: Color):
  text(string, size, color, posn(0,0)) #TODO: Text dimensions
end
# text-font()
# Represents the given string
#   of text with the given font
#   specification
fun make-text-font(string      :: String,
    size        :: Number%(greater-than-zero),
    color       :: Color,
    font-face   :: String, #TODO: Font Face datatype?
    font-family :: String, #TODO: Font Family datatype?
    style       :: String,
    weight      :: String,
    underline   :: Boolean):
  text-font(string, size, color, font-face, 
    font-family, style, weight, 
    underline, posn(0,0))
end

# 
# Helper functions (ported from Racket)
# (Put in an object for organization)
#

helpers = {
  excess : lam(a :: Number%(greater-than-zero), b :: Number%(greater-than-zero), c :: Number%(greater-than-zero)): 
    (num-sqr(a) + num-sqr(b)) - num-sqr(c) end,
  polar-to-posn : lam(radius :: Number%(greater-than-zero), angle :: Number): 
    posn(radius * num-cos(angle), radius * num-sin(angle)) end,
  cos-rel : lam(a :: Number, b :: Number, C :: Number):
    (num-sqr(a) + num-sqr(b)) - (2 * a * b * num-cos(C)) end,
  sin-rel : lam(A :: Number, a :: Number, B :: Number):
    ((a * num-sin(B)) / num-sin(A)) end,
  last-angle : lam(A :: Number, B :: Number):
    ((pi - A) - B) end,
  radians : lam(degree :: Number):
    ((degree / 180.0) * pi) end
}

fun regular-polygon-points(side-length, side-count):
  doc: "Returns a list of vertices for a regular polygon"
  fun add-polar(p :: Position, rad, angle):
    from-polar = helpers.polar-to-posn(rad, angle)
    posn(p.x + from-polar.x, p.y + from-polar.y)
  end
  var ret-lst = empty
  var p = posn(0,0)
  for each(i from range(1, side-count + 1).reverse()):
    ret-lst := link(p, ret-lst)
    p := add-polar(p, side-length, (-2 * pi * ((side-count - i) / side-count)))
  end
  ret-lst
end

fun star-points(in-small-rad, in-large-rad, points):
  small-rad = in-small-rad - 1
  large-rad = in-large-rad - 1
  roff = num-floor(large-rad / 2)
  var ret-lst = empty
  for each(i from range(1, points + 1)):
    this-p = i - 1
    theta1 = 2 * pi * (this-p / points)
    theta2 = 2 * pi * ((this-p - 1/2) / points)
    raw-p1 = helpers.polar-to-posn(small-rad, theta1)
    raw-p2 = helpers.polar-to-posn(large-rad, theta2)
    ret-lst := link(posn(large-rad + raw-p1.x, large-rad + raw-p1.y), 
                    link(posn(large-rad + raw-p2.x, large-rad + raw-p2.y), ret-lst))
  end
  ret-lst
end

#
# Vertex-creating functions (ported from Racket)
# (Put in an object for organization)
#

vertices = {
  triangle-sss : 
    lam(a, b, c):
      A = num-acos(helpers.excess(b, c, a) / (2 * b * c))
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-ass :
    lam(A, b, c):
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-sas :
    lam(a, B, c):
      b-sq = helpers.cos-rel(a, c, B)
      b = num-sqrt(b-sq)
      A = num-acos(helpers.excess(b, c, a) / (2 * b * c))
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-ssa :
    lam(a, b, C):
      c-sq = helpers.cos-rel(a, b, C)
      c = num-sqrt(c-sq)
      A = num-acos(helpers.excess(b, c, a) / (2 * b * c))
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-aas :
    lam(A, B, c):
      C = helpers.last-angle(A, B)
      b = helpers.sin-rel(C, c, B)
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-asa :
    lam(A, b, C):
      B = helpers.last-angle(A, C)
      c = helpers.sin-rel(B, b, C)
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end,
  triangle-saa :
    lam(a, B, C):
      A = helpers.last-angle(B, C)
      b = helpers.sin-rel(A, a, B)
      c = helpers.sin-rel(A, a, C)
      [list: posn(0, 0), posn(c, 0), helpers.polar-to-posn(b, A)]
    end
}

fun make-polygon(shadow vertices :: List<Position>, mode :: Mode, color :: Color) :
  doc: "Creates a polygon with the given vertices, mode, and color"
  # Use an object to simulate a (values ...) expression
  add-point = lam(p :: Position, o :: Object): { x-list : link(p.x, o.x-list), y-list: link(p.y, o.y-list) } end
  lsts = vertices.foldr(add-point, { x-list : empty, y-list : empty })
  poly-matrix = M.lists-to-matrix([list: lsts.x-list, lsts.y-list])
  poly-box = poly-corner-box([list: lsts.x-list, lsts.y-list])
  polygon(poly-matrix, mode, color, poly-box.get-center()).snap-axes()
end

fun make-polygon-star(side-length, side-count, mode, color, adjust):
  make-polygon(adjust(regular-polygon-points(side-length, side-count)), mode, color)
end
    

# triangle()
# Represents an upward-pointing
#   equilateral triangle
fun triangle(side-length :: Number%(greater-than-zero),
    mode        :: Mode,
    color       :: Color) :
  polygon([matrix(2,3): (side-length / 2), 0, side-length, 0, side-length * num-sin(pi / 3), side-length * num-sin(pi / 3)], 
    mode, color, posn((side-length / 2),(side-length / 2) * num-sin(pi / 3))).snap-axes()
end
# right-triangle()
# Represents a right triangle with
#   its right angle at the bottom
#   right and with leg lengths
#   side-length1 and side-length2
fun right-triangle(side-length1 :: Number%(greater-than-zero),
    side-length2 :: Number%(greater-than-zero),
    mode         :: Mode,
    color        :: Color) :
  make-polygon([list: posn(0, (-1 * side-length2)), posn(0, 0), posn(side-length1, 0)], mode, color)
end
# isosceles-triangle()
# Represents an isosceles triangle,
#   where the sides are of length 
#   side-length, and the angle
#   between the two equal-length
#   sides is angle-c
fun isosceles-triangle(side-length :: Number%(greater-than-zero),
    angle-c     :: Number, # Degrees
    mode        :: Mode,
    color       :: Color) :
  offset = (helpers.radians(angle-c) / 2)
  shadow vertices = [list: posn(0, 0), 
                           helpers.polar-to-posn(side-length, (pi / 2) + offset), 
                           helpers.polar-to-posn(side-length, (pi / 2) - offset)]
  make-polygon(vertices, mode, color)
  
  #r-ang = to-radians(angle-c)
  #polygon([matrix(2,3):  0, (2 * (side-length * num-sin(angle-c / 2))), (side-length * num-sin(angle-c / 2)), (side-length * num-cos(angle-c / 2)), (side-length * num-cos(angle-c / 2)), 0], mode, color, posn(side-length * num-sin(r-ang / 2), side-length * num-cos(r-ang / 2))).snap-axes()
end
# triangle-sss()
# Represents a triangle with the
#   given side lengths
fun triangle-sss(side-a :: Number%(greater-than-zero),
    side-b :: Number%(greater-than-zero),
    side-c :: Number%(greater-than-zero),
    mode   :: Mode,
    color  :: Color) :
  make-polygon(vertices.triangle-sss(side-a, side-b, side-c), mode, color)
end
# triangle-ass()
# Represents a triangle with the
#   given angle and two sides.(A-S-S)
fun triangle-ass(angle-a :: Number, # Degrees
   side-b  :: Number%(greater-than-zero),
    side-c  :: Number%(greater-than-zero),
    mode    :: Mode,
    color   :: Color) :
  
  make-polygon(vertices.triangle-ass(helpers.radians(angle-a), side-b, side-c), mode, color)
end
# triangle-sas()
# Represents a triangle with the
#   given angle and two sides.(S-A-S)
fun triangle-sas(side-a  :: Number%(greater-than-zero),
    angle-b :: Number, # Degrees
    side-c  :: Number%(greater-than-zero),
    mode    :: Mode,
    color   :: Color) :
  make-polygon(vertices.triangle-sas(side-a, helpers.radians(angle-b), side-c), mode, color)
end
# triangle-ssa()
# Represents a triangle with the
#   given angle and two sides.(S-S-A)
fun triangle-ssa(side-a  :: Number%(greater-than-zero),
    side-b  :: Number%(greater-than-zero),
    angle-c :: Number, # Degrees
    mode    :: Mode,
    color   :: Color) :
  make-polygon(vertices.triangle-ssa(side-a, side-b, helpers.radians(angle-c)), mode, color)
end
# triangle-aas()
# Represents a triangle with the
#   given angle and two sides.(A-A-S)
fun triangle-aas(angle-a :: Number, # Degrees
    angle-b :: Number, # Degrees
    side-c  :: Number%(greater-than-zero),
    mode    :: Mode,
    color   :: Color) :
  make-polygon(vertices.triangle-aas(helpers.radians(angle-a), helpers.radians(angle-b), side-c), mode, color)
end
  # triangle-asa()
  # Represents a triangle with the
  #   given angle and two sides.(A-S-A)
fun triangle-asa(angle-a :: Number, # Degrees
                 side-b  :: Number%(greater-than-zero),
                 angle-c :: Number, # Degrees
                 mode    :: Mode,
                 color   :: Color):
  make-polygon(vertices.triangle-asa(helpers.radians(angle-a), side-b, helpers.radians(angle-c)), mode, color)
end
  # triangle-saa()
  # Represents a triangle with the
  #   given angle and two sides.(S-A-A)
fun triangle-saa(side-a  :: Number%(greater-than-zero),
                 angle-b :: Number, # Degrees
                 angle-c :: Number, # Degrees
                 mode    :: Mode,
                 color   :: Color) :
  make-polygon(vertices.triangle-saa(side-a, helpers.radians(angle-b), helpers.radians(angle-c)), mode, color)
end
  # square()
  # Represents a square of the given side length
fun square(side-length :: Number%(greater-than-zero),
           mode        :: Mode,
           color       :: Color) :
  polygon([matrix(2,4):  0, 0, side-length, side-length,
      0, side-length, side-length, 0], mode, color, posn((side-length / 2), (side-length / 2))).snap-axes()
end
  # rectangle()
  # Represents a rectangle with the
  #   given two side lengths
fun make-rectangle(width  :: Number%(greater-than-zero),
              height :: Number%(greater-than-zero),
              mode   :: Mode,
              color  :: Color) :
  rectangle(polygon, width, height, mode, color)
end
  # rhombus()
  # Represents a rhombus with the given
  #   side length and the given top/bottom
  #   angle
fun rhombus(side-length :: Number%(greater-than-zero),
            angle       :: Number, # Degrees
            mode        :: Mode,
            color       :: Color) :
  beta = (pi / 2) - (to-radians(angle) / 2)
      polygon([matrix(2,4): 0, side-length * num-cos(beta), 2 * (side-length * num-cos(beta)), side-length * num-cos(beta),
        side-length * num-sin(beta), 0, side-length * num-sin(beta), 2 * (side-length * num-sin(beta))], mode, color, posn((side-length * num-cos(beta)), (side-length * num-sin(beta)))).snap-axes()
end
  # star()
  # Represents a 5-pointed star of
  #   the given side length
fun star(side-length :: Number%(greater-than-zero),
         mode        :: Mode,
         color       :: Color) :
  make-polygon-star(side-length, 5, mode, color, lam(l): reorder-step(l, 2) end)
end
      
  # radial-star()
  # Represents a star with the given
  #   amount of points; the outer
  #   points will be a distance of
  #   outer from the center, the inner
  #   a distance of inner
fun radial-star(point-count :: Number%(nonzero-nat),
                outer       :: Number%(greater-than-zero),
                inner       :: Number%(greater-than-zero),
                mode        :: Mode,
                color       :: Color) :
  make-polygon(star-points(outer, inner, point-count), mode, color)
end
  # star-sized()
  # Same as radial-star().
fun star-sized(point-count :: Number%(nonzero-nat),
               outer       :: Number%(greater-than-zero),
               inner       :: Number%(greater-than-zero),
               mode        :: Mode,
               color       :: Color) :
  radial-star(point-count, outer, inner, mode, color)
end
  # star-polygon()
  # Represents a regular star polygon,
  #   with every step-th vertex connected
fun star-polygon(side-length :: Number%(greater-than-zero),
                 point-count :: Number%(nonzero-nat),
                 step        :: Number%(nonzero-nat),
                 mode        :: Mode,
                 color       :: Color) :
  make-polygon-star(side-length, point-count, mode, color, lam(l): reorder-step(l, step) end)
end
  # regular-polygon()
  # Represents a regular polygon
  #   with the given number of sides.
fun regular-polygon(length :: Number%(greater-than-zero),
                    count  :: Number%(nonzero-nat),
                    mode   :: Mode,
                    color  :: Color) :
  make-polygon-star(length, count, mode, color, lam(x): x end)
end
  # empty-image()
  # Represents an empty image
  #   of the given size.
fun empty-image(x :: Number%(greater-than-zero),
                y :: Number%(greater-than-zero)) :
  make-rectangle(x,y,outline,black)
end




##################
# IMAGE PREDICATES
##################

# TODO: Probably get rid of these

fun is-regular-n-gon(n :: Number) -> (Image -> Boolean):
  doc: "Returns a Predicate which returns true if the given image is a regular n-gon"
  about-eq = lam(a, b): num-abs(a - b) <= num-expt(10,-11) end
  lam(i :: Image):
    # dispMtx represents the displacement vectors
    #   of each point in the image's matrix (i.e. it's sides)
    # If the magnitude of each displacement vector is the same
    #   and their dot products are equal, then they all have the
    #   the same angles between one another. Thus, the image must be
    #   a regular polygon.
    shiftedMtx = M.vectors-to-matrix(i.matrix.to-vectors().drop(i.matrix.cols - 1) + i.matrix.to-vectors().take(i.matrix.cols - 1))
    dispMtx = i.matrix - shiftedMtx
    vecs = dispMtx.to-vectors()
    firstDot = M.dot(vecs.first, vecs.get(1))
    firstMag = M.magnitude(vecs.first)
    len = vecs.length()
    ((len == n) and is-polygon(i)) and
    ((fold(lam(acc, v): acc and about-eq(v,firstMag) end, true, vecs.map(M.magnitude))) and
    (for fold(acc from true, j from range(0,len)):
        acc and about-eq(M.dot(vecs.get(j), vecs.get(num-modulo(j + 1, len))), firstDot)
    end))
  end
end

fun is-triangle(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a polygon"
  # Polygon with 3 Vertices
  is-polygon(img) and (img.matrix.cols == 3)
end

is-equilateral-triangle = is-regular-n-gon(3)

fun is-rectangle(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a rectangle"
  is-polygon(img) and (img.matrix.cols == 4)
end

is-square = is-regular-n-gon(4)

fun is-pentagon(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a pentagon"
  is-polygon(img) and (img.matrix.cols == 5)
end

is-regular-pentagon = is-regular-n-gon(5)

fun is-hexagon(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a hexagon"
  is-polygon(img) and (img.matrix.cols == 6)
end

is-regular-hexagon = is-regular-n-gon(6)

fun is-ellipse(img :: Image) -> Boolean:
  doc: "Returns true if the given image is an ellipse"
  # Using Properties of the Bezier Representation of Ellipses
  about-eq = lam(a, b): num-abs(a - b) <= num-expt(10,-11) end
  dispMtxMags = (img.matrix - (img.matrix.submatrix(range(0,img.matrix.rows), 
      [list: img.matrix.cols - 1] ).augment(
      img.matrix.submatrix(range(0,img.matrix.rows),range(0,(img.matrix.cols - 1)))))).to-vectors().map(M.magnitude)
  
  (is-bezier-shape(img) and (img.matrix.cols == 13)) and
  (for fold2(acc from true, v from dispMtxMags.take(6), w from dispMtxMags.reverse().take(6)):
      acc and about-eq(v,w)
    end)
end

fun is-circle(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a circle"
  b = points-bounding-box(img.matrix)
  is-ellipse(img) and (b.width == b.height)
end



##########################
# TRANSFORMATION FUNCTIONS
##########################


fun get-bounding-box-mtx(img :: Image) -> M.Matrix:
  doc: "Returns the bounding box's matrix for the given image"
  cases(Image) img:
    | rotated-image(angle, image, center, _,_) => 
      rst = get-bounding-box-mtx(image)
      affine-transform-matrix(rotation-matrix(angle),rst,mtx-center(rst))
    | scaled-image(x-scale,y-scale,image,_,_,_)=>
      rst = get-bounding-box-mtx(image)
      affine-transform-matrix(scale-xy-matrix(x-scale,y-scale),rst,mtx-center(rst))
    | text(_,_,_,_) => raise("Not yet implemented")
    | text-font(_,_,_,_,_,_,_,_,_) => raise("Not yet implemented")
    | else => img.to-matrix()
  end
end

fun bounding-box(img :: Image) -> Box:
  points-bounding-box(get-bounding-box-mtx(img))
end

fun snap-trans(img :: Image) -> M.Vector:
  rws = img.matrix.to-lists()
  min-x = rws.first.sort().first
  min-y = rws.get(1).sort().first
  trans-x = if (min-x > 0):
    num-abs(min-x)
  else:
    -1 * min-x
  end
  trans-y = if (min-y > 0):
    num-abs(min-y)
  else:
    -1 * min-y
  end
  [vector: trans-x, trans-y]
end

fun snap-axes(img :: Image) -> Image:
  if is-compound-image(img):
    t-trans = snap-trans(img.top)
    b-trans = snap-trans(img.bottom)
    c-trans = map2(num-max,t-trans,b-trans)
    img.translate(c-trans)
  else:
    img.translate(snap-trans(img))
  end
end
    

###########################
# IMAGE COMBINING FUNCTIONS
###########################

# Begin Helper Functions

fun new-center(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Position:
  doc: "Returns the center coordinate of the first given image placed on the second at the given position"
  nb = new-box(i1,x,y,i2, i1.get-center())
  posn(nb.width / 2, nb.height / 2)
end

# TODO: Find a better fix
# (This is temporary)
fun fix-overlay-center(i1 :: Image, at :: Position, old-center :: Position) -> Position:
  doc: "Returns the adjusted center for overlays"
  shifted-top = i1.translate([vector: (-1 * i1.get-center().x) + at.x, (-1 * i1.get-center().y) + at.y])
  sv = shifted-top.snap-vec()
  posn(old-center.x + num-max(0,sv.first),
    old-center.y + num-max(0,sv.get(1)))
end

fun pin-to-one(i :: Image, use-top :: Boolean) -> Image:
  cases(Image) i:
    | clipped-image(pair, hidden) => 
      #Always re-pin to background on clipped image
      clipped-image(compound-image(pair.top, pair.at, pair.bottom, pair.bottom.get-center()), hidden)
    | compound-image(top, at, bottom, pin) =>
      dvec = calc-compound-vector(top, bottom, bottom.get-center(), at)
      trans-topx-p = dvec.first  >= 0 
      trans-topy-p = dvec.get(1) >= 0
      dtx = if trans-topx-p: dvec.first  else: 0 end
      dty = if trans-topy-p: dvec.get(1) else: 0 end
      dbx = if trans-topx-p: 0 else: -1 * dvec.first  end
      dby = if trans-topy-p: 0 else: -1 * dvec.get(1) end
      top-trans-box = top.cornerbox().translate(dtx, dty)
      bot-trans-box = bottom.cornerbox().translate(dbx, dby)
      make-pin = if use-top: top.make-pinhole else: bottom.make-pinhole end
      joined = top-trans-box.join(bot-trans-box)
      rel-pin = if use-top: top.get-pinhole() else: bottom.get-pinhole() end
      pin-box = if use-top: top-trans-box else: bot-trans-box end
      real-pin = posn(pin-box.top-left.x + rel-pin.x, pin-box.top-left.y + rel-pin.y)
      new-pin = make-pin(real-pin.x - joined.top-left.x, real-pin.y - joined.top-left.y)
      compound-image(top, at, bottom, new-pin)
    | else => i
  end
end

# Convienence functions:
pin-to-top = lam(i): pin-to-one(i, true) end
pin-to-bottom = lam(i): pin-to-one(i, false) end
  

# End Helper Functions

# Begin Overlay Functions
fun overlay(i1 :: Image, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second"
  #i2-no-pin = i2.clear-pinhole()
  #i2-no-pin-center = i2-no-pin.get-center()
  i2-center = i2.get-center()
  pin-to-top(compound-image(i1, i2-center, i2, i2-center).snap-axes())
end

fun overlay-pinhole(i1 :: Image, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second using their pinholes"
  #Note: Default pinhole is true center
  #TODO: Find better fix than this translation vector
  # basis = bot-img.coord-zero()
  # true-at = posn(at.x + basis.x, at.y + basis.y)
  # tpin = top-img.get-pinhole()
  # 
  # dvec = [list: true-at.x - tpin.x, true-at.y - tpin.y] calc-compound-vector(top, bottom, bottom.get-center(), at)
  # trans-topx-p = dvec.first  >= 0 
  # trans-topy-p = dvec.get(1) >= 0
  # dtx = if trans-topx-p: dvec.first  else: 0 end
  # dty = if trans-topy-p: dvec.get(1) else: 0 end
  # dbx = if trans-topx-p: 0 else: -1 * dvec.first  end
  # dby = if trans-topy-p: 0 else: -1 * dvec.get(1) end
  #tc = i1.get-pinhole()
  #comp-top = i1.translate([vector: i2.get-pinhole().x - tc.x, i2.get-pinhole().y - tc.y])
  #sv = compound-image(comp-top, i2.get-pinhole(), i2, i2.get-pinhole()).snap-vec()
  #pin-to-top(compound-image(comp-top.translate(sv), i2.get-pinhole(), i2.translate(sv), translate-posn(i2.get-pinhole(),sv)).snap-axes())
  tpin = i1.get-pinhole()
  bpin = i2.get-pinhole()
  overlay-xy(i1, tpin.x - bpin.x, tpin.y - bpin.y, i2)
end

fun overlay-align(xp :: X-Place, yp :: Y-Place, i1 :: Image, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second with the given alignments"
  #i1 = ri1.clear-pinhole()
  #i2 = ri2.clear-pinhole()
  tb = i1.get-box()
  bb = i2.get-box()
  xpos = cases(X-Place) xp:
    | x-left => tb.width / 2
    | x-center => i2.get-center().x
    | x-right => bb.width - (tb.width / 2)
  end
  ypos = cases(Y-Place) yp:
    | y-top => tb.height / 2
    | y-center => i2.get-center().y
    | y-bottom => bb.height - (tb.height / 2)
  end
  new-c = new-center(i1,xpos,ypos,i2)
  pin-to-top(compound-image(i1, posn(xpos, ypos), i2, new-c).snap-axes())
end

fun overlay-offset(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second after shifting the second x pixels to the right and y down"
  #i1-np = i1.clear-pinhole()
  #i2-np = i2.clear-pinhole()
  i2-center = i2.get-center()
  at = posn(i2-center.x - x, i2-center.y - y)
  new-c = new-center(i1,at.x,at.y,i2)
  pin-to-top(compound-image(i1, at, i2, new-c).clear-pinhole().snap-axes())
end

fun overlay-align-offset(xp :: X-Place, yp :: Y-Place, i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second with the given alignments after shifting it x pixels to the right and y down"
  #i1 = ri1.clear-pinhole()
  #i2 = ri2.clear-pinhole()
  tb = i1.get-box()
  bb = i2.get-box()
  xpos = cases(X-Place) xp:
    | x-left => (tb.width / 2) - x
    | x-center => (i2.get-center().x - x)
    | x-right => (bb.width - (tb.width / 2)) - x
  end
  ypos = cases(Y-Place) yp:
    | y-top => (tb.height / 2) - y
    | y-center => (i2.get-center().y - y)
    | y-bottom => (bb.height - (tb.height / 2)) - y
  end
  new-c = new-center(i1,xpos,ypos,i2)
  pin-to-top(compound-image(i1, posn(xpos, ypos), i2, new-c).snap-axes())
end

fun overlay-xy(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  # Identical to underlay-xy(i2,(-1 * x), (-1 * y), i1)
  doc: "Overlays the first image onto the second. The images are initially lined up on their upper-left corners and then the bottom one is shifted to the right by x to and down by y."
  #i1 = ri1.clear-pinhole()
  #i2 = ri2.clear-pinhole()
  tb = i1.get-box()
  at = posn((tb.width / 2) - x, (tb.height / 2) - y)
  new-c = new-center(i1, at.x, at.y, i2)
  pin-to-top(compound-image(i1, at, i2, new-c).snap-axes())
end

# End Overlay Functions

# Begin Underlay Functions

# (IMHO Bug fixes will be easier if these are wrappers for overlay functions)
# If there's some performance loss or something because of this, let me know

fun underlay(i1 :: Image, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second (like overlay, but in reverse order)"
  pin-to-bottom(overlay(i2, i1))
end

fun underlay-pinhole(i1 :: Image, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second using their pinholes"
  pin-to-bottom(overlay-pinhole(i2,i1))
end

fun underlay-align(xp :: X-Place, yp :: Y-Place, i1 :: Image, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second with the given alignments"
  pin-to-bottom(overlay-align(xp, yp, i2, i1))
end


fun underlay-offset(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second, after offsetting it right and down by the given amount"
  pin-to-bottom(overlay-offset(i2, (-1 * x), (-1 * y), i1))
end

fun underlay-align-offset(xp :: X-Place, yp :: Y-Place, i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second with the given alignments, after offsetting it right and down by the given amount"
  pin-to-bottom(overlay-align-offset(xp, yp, i2, (-1 * x), (-1 * y), i1))
end

fun underlay-xy(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second by aligning their top left corners and shifting the second right and down by the given amount"
  pin-to-bottom(overlay-xy(i2, (-1 * x), (-1 * y), i1))
end

fun beside(i1 :: Image, i2 :: Image) -> Image:
  doc: "Places the second image next to the first, with their centers vertically aligned"
  first-is-left = i1.get-center().x <= i2.get-center().x
  #i1 = if first-is-left: ri1.clear-pinhole() else: ri2.clear-pinhole() end
  #i2 = if first-is-left: ri2.clear-pinhole() else: ri1.clear-pinhole() end
  #i1 = ri1.clear-pinhole()
  #i2 = ri2.clear-pinhole()
  fb = i1.get-box()
  sb = i2.get-box()
  at = posn(fb.width + (sb.width / 2), i1.get-center().y)
  new-c = new-center(i2,at.x,at.y,i1)
  pin-to-bottom(compound-image(i2,at,i1,new-c).snap-axes())
end

fun beside-list(imgs :: List<Image>) -> Image:
  doc: "Places the list of images next to one another, with the first image on the left"
  swapped = lam(i1, i2): beside(i2, i1) end
  imgs.rest.foldl(swapped,imgs.first)
end

fun beside-align(yp :: Y-Place, i1 :: Image, i2 :: Image) -> Image:
  doc: "Places the second image next to the first, with the given vertical alignment"
  #i1 = ri1.clear-pinhole()
  #i2 = ri2.clear-pinhole()
  fb = i1.get-box()
  sb = i2.get-box()
  xpos = fb.width + (sb.width / 2)
  ypos = cases(Y-Place) yp:
    | y-top => (sb.height / 2)
    | y-center => i1.get-center().y
    | y-bottom => fb.height - (sb.height / 2)
  end
  new-c = new-center(i2, xpos, ypos, i1)
  pin-to-bottom(compound-image(i2,posn(xpos,ypos),i1,new-c).snap-axes())
end

fun beside-align-list(yp :: Y-Place, imgs :: List<Image>) -> Image:
  doc: "Places the list of images next to one another with the given alignment, with the first image on the left"
  with-yp = lam(i2, i1): beside-align(yp, i1, i2) end
  imgs.rest.foldl(with-yp,imgs.first)
end

fun above(i1 :: Image, i2 :: Image) -> Image:
  doc: "Places the first image above the second, with their centers horizontally aligned"
  #i1 = ri1.clear-pinhole()
  #i2 = ri2.clear-pinhole()
  i1cb = i1.cornerbox()
  i2cb = i2.cornerbox()
  i1-box = i1cb.to-box()
  i1-center = i1cb.get-center()
  i2-box = i2cb.to-box()
  at-x = i1-center.x
  at-y = i1-box.height + i2cb.get-center().y
  at = posn(at-x, at-y)
  new-c = new-center(i2,at.x,at.y,i1)
  pin-to-bottom(compound-image(i2,at,i1,new-c).snap-axes())
end

fun above-list(imgs :: List<Image>) -> Image:
  doc: "Places the list of images on top of one another, with the first image on the top"
  swapped = lam(i1, i2): above(i2, i1) end
  imgs.rest.foldl(swapped, imgs.first)
end

fun above-align(xp :: X-Place, i1 :: Image, i2 :: Image) -> Image:
  doc: "Places the first image above the second, with the given horizontal alignment"
  #i1 = ri1.clear-pinhole()
  #i2 = ri2.clear-pinhole()
  i1cb = i1.cornerbox()
  i1-box = i1cb.to-box()
  i1-center = i1cb.get-center()
  i2cb = i2.cornerbox()
  i2-box = i2cb.to-box()
  i2-center = i2cb.get-center()
  xpos = cases(X-Place) xp:
    | x-left => i2-center.x
    | x-center => i1-center.x
    | x-right => i1-box.width - i2-center.x
  end
  ypos = i1-box.height + i2-center.y
  new-c = new-center(i2,xpos,ypos,i1)
  pin-to-bottom(compound-image(i2, posn(xpos, ypos), i1, new-c).snap-axes())
end

fun above-align-list(xp :: X-Place, imgs :: List<Image>) -> Image:
  doc: "Places the list of images on top of one another with the given alignment, with the first image on top"
  with-xp = lam(i1, i2): above-align(xp, i2, i1) end
  #len = imgs.length()
  #imgs.take(len - 1).foldl(with-xp, imgs.last())
  imgs.rest.foldl(with-xp, imgs.first)
end

fun empty-scene(x :: Number%(greater-than-zero),
                y :: Number%(greater-than-zero)) :
  overlay(make-rectangle(x,y,outline,black), make-rectangle(x,y,solid,white))
end

fun colored-empty-scene(x :: Number%(greater-than-zero),
                y :: Number%(greater-than-zero),
                k :: Color) :
  overlay(make-rectangle(x,y,outline,black), make-rectangle(x,y,solid,k))
end

fun place-image-topleft(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  #i1 = ri1.clear-pinhole()
  #i2 = ri2.clear-pinhole()
  tb = i1.get-box()
  at = posn((tb.width / 2) + x, (tb.height / 2) + y)
  pin-to-bottom(clipped-image(compound-image(i1, at, i2, i2.get-center()), false))
end

fun overlay-at(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  #ri1 = i1.clear-pinhole()
  #ri2 = i2.clear-pinhole()
  pin-to-top(compound-image(i1, posn(x,y), i2, i2.get-center()))
end

fun place-image(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Places the first image onto the second, clipping it so that it is no larger than the bottom"
  #ri1 = i1.clear-pinhole()
  #ri2 = i2.clear-pinhole()
  if not(is-clipped-image(i2)):
    clipped-image(compound-image(i1, posn(x,y), i2, i2.get-center()),false)
  else:
    # Combine the tops to avoid unneeded mask propogation
    trans-vec = [vector: i2.pair.at.x - i2.pair.top.get-center().x, 
      i2.pair.at.y - i2.pair.top.get-center().y]
    basis = i2.pair.top.translate(trans-vec).coord-zero()
    comb-at = posn(x - basis.x, y - basis.y)
    new-top = pin-to-bottom(compound-image(i1, comb-at,i2.pair.top,new-center(i1,comb-at.x,comb-at.y,i2.pair.top)))
    diff-c = posn(i2.pair.top.get-center().x - new-top.get-center().x, 
                  i2.pair.top.get-center().y - new-top.get-center().y)
    new-at = posn(i2.pair.at.x - diff-c.x, i2.pair.at.y - diff-c.y)
    pin-to-bottom(clipped-image(compound-image(new-top, new-at, i2.pair.bottom, i2.pair.get-center()),i2.hidden-mask))
  end
end

fun place-images(imgs :: List<Image>, posns :: List<Position>, base :: Image) -> Image:
  doc: "Places the given list of images onto the given base image (the first being on top) at the given positions"
  placelam = lam(acc, i, p): place-image(i, p.x, p.y, acc) end
  fold2(placelam,base,imgs,posns)
end

fun place-image-align(i1 :: Image, x :: Number, y :: Number, xp :: X-Place, yp :: Y-Place, i2 :: Image):
  tb = i1.get-box()
  xpos = cases(X-Place) xp:
    | x-left => (tb.width / 2) + x
    | x-center => x
    | x-right => (-1 * (tb.width / 2)) + x
  end
  ypos = cases(Y-Place) yp:
    | y-top => (tb.height / 2) + y
    | y-center => y
    | y-bottom => (-1 * (tb.height / 2)) + y
  end
  place-image(i1, xpos, ypos, i2)
end

fun place-images-align(imgs :: List<Image>, 
                       posns :: List<Position>, 
                       x-place :: X-Place, 
                       y-place :: Y-Place, 
                       scene :: Image) -> Image:
  placelam = lam(acc, i, p): place-image-align(i, p.x, p.y, x-place, y-place, acc) end
  fold2(placelam, scene, imgs, posns)
end

############
# OTHER IMAGE FUNCTIONS
############

fun frame(i :: Image) -> Image:
  doc: "Returns the given image with a black frame around it"
  bb = i.get-box()
  overlay(make-rectangle(bb.width, bb.height, outline, black), i)
end

############
# MORE LINES AND CURVES
############

fun add-line(image :: Image, x1 :: Number, y1 :: Number, x2 :: Number, y2 :: Number, pen-or-color :: Color) -> Image:
  doc: "Adds a line to the given image"
  dx = x2 - x1
  dy = y2 - y1
  line-to-add = line(dx, dy, pen-or-color)
  overlay-xy(line-to-add, -1 * num-min(x1, x2), -1 * num-min(y1, y2), image)
end

fun add-line-to-scene(scene :: Image, 
                      x1 :: Number, 
                      y1 :: Number, 
                      x2 :: Number, 
                      y2 :: Number, 
                      pen-or-color :: Color) -> Image:
  doc: "Adds a line to the given scene, cropping the resulting image to the size of scene"
  dx = x2 - x1
  dy = y2 - y1
  line-to-add = line(dx, dy, pen-or-color)
  place-image-topleft(line-to-add, num-min(x1, x2), num-min(y1, y2), scene)
end

fun add-curve(image :: Image, 
              x1 :: Number,
              y1 :: Number,
              angle1 :: Number,
              pull1 :: Number,
              x2 :: Number,
              y2 :: Number,
              angle2 :: Number,
              pull2 :: Number,
              pen-or-color :: Color) -> Image:
  dx = x2 - x1
  dy = y2 - y1
  leftx = num-min(x1, x2)
  rightx = num-max(x1, x2)
  topy = num-min(y1, y2)
  boty = num-max(y1, y2)
  place-at = cornerbox(posn(leftx, topy), posn(rightx, boty)).get-center()
  curve-to-add = curve(angle1, pull1, dx, dy, angle2, pull2, pen-or-color)
  # curve-cb = curve-to-add.cornerbox()
  # off-x = num-max(0, curve-cb.top-left.x - leftx)
  # off-y = num-max(0, curve-cb.top-left.y - topy)
  # overlay-xy(curve-to-add, -1 * (leftx - off-x), -1 * (topy - off-y), image)
  overlay-at(curve-to-add, place-at.x, place-at.y, image)
end

fun add-curve-to-scene(scene :: Image,
                       x1 :: Number,
                       y1 :: Number,
                       angle1 :: Number,
                       pull1 :: Number,
                       x2 :: Number,
                       y2 :: Number,
                       angle2 :: Number,
                       pull2 :: Number,
                       pen-or-color :: Color) -> Image:
  dx = x2 - x1
  dy = y2 - y1
  leftx = num-min(x1, x2)
  rightx = num-max(x1, x2)
  topy = num-min(y1, y2)
  boty = num-max(y1, y2)
  place-at = cornerbox(posn(leftx, topy), posn(rightx, boty)).get-center()
  curve-to-add = curve(angle1, pull1, dx, dy, angle2, pull2, pen-or-color)
  # curve-cb = curve-to-add.cornerbox()
  # off-x = num-max(0, curve-cb.top-left.x - leftx)
  # off-y = num-max(0, curve-cb.top-left.y - topy)
  # place-image-topleft(curve-to-add, leftx - off-x, topy - off-y, scene)
  place-image(curve-to-add, place-at.x, place-at.y, scene)
end

############
# MORE POLYGONS
############
fun make-polygon-from-points(shadow vertices :: List<Position>, mode :: Mode, color :: Color) -> Image:
  x-list = vertices.map(lam(p): p.x end)
  y-list = vertices.map(lam(p): p.y end)
  mtx = M.lists-to-matrix([list: x-list, y-list])
  cb = poly-corner-box([list: x-list, y-list])
  polygon(mtx, mode, color, cb.get-center()).snap-axes()
end

fun add-polygon(image :: Image, posns :: List<Position>, mode :: Mode, color :: Color) -> Image:
  x-list = posns.map(lam(p): p.x end)
  y-list = posns.map(lam(p): p.y end)
  mtx = M.lists-to-matrix([list: x-list, y-list])
  cb = poly-corner-box([list: x-list, y-list])
  true-center = cb.get-center()
  poly = polygon(mtx, mode, color, cb.get-center()).snap-axes()
  # snap-center = poly.get-center()
  # off-x = snap-center.x - true-center.x
  # off-y = snap-center.y - true-center.y
  overlay-at(poly, true-center.x, true-center.y, image)
end

fun add-polygon-to-scene(image :: Image, posns :: List<Position>, mode :: Mode, color :: Color) -> Image:
  x-list = posns.map(lam(p): p.x end)
  y-list = posns.map(lam(p): p.y end)
  mtx = M.lists-to-matrix([list: x-list, y-list])
  cb = poly-corner-box([list: x-list, y-list])
  center = cb.get-center()
  poly = polygon(mtx, mode, color, cb.get-center()).snap-axes()
  place-image(poly, center.x, center.y, image)
end

############
# SVG RENDERING FUNCTIONS
############

fun raw-svg-rect(top-left :: Position, width :: Number, height :: Number):
  x-attr = XML.attribute("x", XML.atomic(top-left.x))
  y-attr = XML.attribute("y", XML.atomic(top-left.y))
  width-attr = XML.attribute("width", XML.atomic(width))
  height-attr = XML.attribute("height", XML.atomic(height))
  style-attr = XML.attribute("style", XML.atomic("fill:none;stroke:black;stroke-width:1;"))
  XML.tag("rect", [list: x-attr, y-attr, width-attr, height-attr, style-attr], empty)
end

fun raw-svg-dot(pos :: Position):
  x-attr = XML.attribute("cx", XML.atomic(pos.x))
  y-attr = XML.attribute("cy", XML.atomic(pos.y))
  radius-attr = XML.attribute("r", XML.atomic(3))
  stroke-attr = XML.attribute("stroke", XML.atomic("black"))
  stroke-width-attr = XML.attribute("stroke-width", XML.atomic(1))
  fill-attr = XML.attribute("fill", XML.atomic("none"))
  XML.tag("circle", [list: x-attr, y-attr, radius-attr, stroke-attr, stroke-width-attr, fill-attr], empty)
end

fun svg-pinhole-lines(intersection :: Position, img-width :: Number, img-height :: Number):
  black-attr = XML.attribute("stroke", XML.atomic("black"))
  white-attr = XML.attribute("stroke", XML.atomic("white"))
  stroke-width-attr = XML.attribute("stroke-width", XML.atomic(1))
  fun vert-line(x-pos :: Number, color :: XML.Attribute):
    x1 = XML.attribute("x1", XML.atomic(x-pos))
    x2 = XML.attribute("x2", XML.atomic(x-pos))
    y1 = XML.attribute("y1", XML.atomic(0))
    y2 = XML.attribute("y2", XML.atomic(img-height))
    XML.tag("line", [list: x1, x2, y1, y2, color, stroke-width-attr], empty)
  end
  fun horiz-line(y-pos :: Number, color :: XML.Attribute):
    x1 = XML.attribute("x1", XML.atomic(0))
    x2 = XML.attribute("x2", XML.atomic(img-width))
    y1 = XML.attribute("y1", XML.atomic(y-pos))
    y2 = XML.attribute("y2", XML.atomic(y-pos))
    XML.tag("line", [list: x1, x2, y1, y2, color, stroke-width-attr], empty)
  end
  white-intersect = posn(intersection.x + 1/2, intersection.y + 1/2)
  black-intersect = posn(intersection.x - 1/2, intersection.y - 1/2)
  bvert  =  vert-line(black-intersect.x, black-attr)
  bhoriz = horiz-line(black-intersect.y, black-attr)
  wvert  =  vert-line(white-intersect.x, white-attr)
  whoriz = horiz-line(white-intersect.y, white-attr)
  XML.tag("g", empty, [list: bvert, bhoriz, wvert, whoriz])
end

fun num-inexact-string(n :: Number) -> String:
  doc: "Returns a string with a decimal representation of the given number"
  num-to-string-digits(num-exact(n), 10)
end

fun point-to-string(pt :: Position):
  num-inexact-string(pt.x) + "," + num-inexact-string(pt.y) + " "
where:
  point-to-string(posn(25,34)) is "25,34 "
end

fun draw-polygon(i :: Image%(is-polygon)) -> XML.Element:
  doc: "Returns the <polygon> tag corresponding to the given polygon"
  
  points = XML.attribute("points", XML.atomic(for fold(acc from "", p from matrix-to-posns(i.matrix)):
    acc + point-to-string(p)
  end))
  
  # col-str = "rgba(" 
    # + num-tostring(i.color.red) + "," 
    # + num-tostring(i.color.green) + "," 
    # + num-tostring(i.color.blue) + "," 
    # + num-tostring(i.color.alpha) + ")"
  
  # style-str = cases(Mode) i.mode:
    # | solid => "fill:" + col-str + ";"
    # | outline => "stroke:" + col-str + ";stroke-width: 2; fill: none;"
  # end
  
  style-attributes = cases(Mode) i.mode:
    | solid => i.color.solid-xml-attributes()
    | outline => link(XML.attribute("fill", XML.atomic("none")), i.color.outline-xml-attributes())
  end
  XML.tag("polygon", link(points, style-attributes), empty)
end


fun draw-bezier-shape(i :: Image%(is-bezier-shape)) -> XML.Element:
  doc: "Returns the <path> tag corresponding to the given bezier-curve-defined shape"
  # USAGE: (note: i.matrix.cols % 3 == 1)
  # The first position in the matrix is the move-to point
  #   and the remaining ones are Cubic Bezier control points
  # IF YOU DON'T KNOW WHAT THAT MEANS YOU SHOULDN'T BE CALLING THIS
  fun curve-string(lst :: List<Position>):
    if not(num-modulo(lst.length(),3) == 0):
      raise("Invalid Bezier Shape")
    else:
      fun recur-string(acc, l :: List<Position>):
        cases(List) l:
          | empty => acc
          | link(f,r) => recur-string(acc + ("C " + fold(string-append, "",map(point-to-string,l.take(3)))), l.drop(3))
        end
      end
      recur-string("",lst)
    end
  end
  
  raw-pts = matrix-to-posns(i.matrix)
   
  points = XML.attribute("d", XML.atomic("M" + (point-to-string(raw-pts.first) + curve-string(raw-pts.rest))))
  
  # col-str = "rgba(" 
    # + num-tostring(i.color.red) + "," 
    # + num-tostring(i.color.green) + "," 
    # + num-tostring(i.color.blue) + "," 
    # + num-inexact-string(i.color.alpha / 255) + ")"
  
  # style-str = cases(Mode) i.mode:
    # | solid => "fill:" + col-str + ";"
    # | outline => "stroke:" + col-str + ";stroke-width: " + num-tostring(DEFAULT_OUTLINE_WIDTH) + "; fill: none;"
  # end
  
  style-attributes = cases(Mode) i.mode:
    | solid => i.color.solid-xml-attributes()
    | outline => link(XML.attribute("fill", XML.atomic("none")), i.color.outline-xml-attributes())
  end
  XML.tag("path", link(points, style-attributes), empty)
end

fun wrap-and-name(prefix :: Number, n :: Number, elt :: XML.Element) -> XML.Element:
  id-str = XML.attribute("id", XML.atomic(num-tostring(prefix) + "_" + num-tostring(n)))
  shape-id-str = XML.attribute("id", XML.atomic(num-tostring(prefix) + "_" + num-tostring(n) + "_shape"))
  new-elt = XML.tag(elt.name, elt.attributes + [list: shape-id-str], elt.elts)
  XML.tag("clipPath", [list: id-str], [list: new-elt])
end

fun get-clip-intersect(prefix :: Number, clips :: List<XML.Element>, width :: Number, height :: Number) -> List<XML.Element>:
  len = clips.length()
  when len == 0:
    raise("Cannot clip image without clip")
  end
  id-att = lam(num): XML.attribute("id", XML.atomic(num-tostring(prefix) + "_" + num-tostring(num) + "_clip")) end
  first-path-att = lam(num): XML.attribute("clip-path", XML.atomic("url(#" + num-tostring(prefix) + "_" + num-tostring(num) + ")")) end
  path-att = lam(num): XML.attribute("clip-path", XML.atomic("url(#" + num-tostring(prefix) + "_" + num-tostring(num) + "_clip)")) end
  shape-id = lam(num): num-tostring(prefix) + "_" + num-tostring(num) + "_shape" end
  use-tag = lam(num): XML.tag("use", [list: 
        XML.attribute("x",XML.atomic("0")), 
        XML.attribute("y",XML.atomic("0")), 
        XML.attribute("width",XML.atomic(width)), 
        XML.attribute("height",XML.atomic(height)), 
        XML.attribute("xlink:href",XML.atomic("#" + shape-id(num)))], empty) 
  end
  if len == 1:
    [list: XML.tag("clipPath", [list: id-att(0)], [list: use-tag(0)])]
  else:
    start = XML.tag("clipPath", [list: id-att(len - 2), first-path-att(len - 1)], [list: use-tag(len - 2)])
    (for fold(acc from [list: start], n from range(0,len - 2).reverse()):
        link(XML.tag("clipPath", [list: id-att(n), path-att(n + 1)], [list: use-tag(n)]), acc)
      end).reverse()
  end
end

data ClipInfo:
  | clip-pair(defs :: XML.Element, useClip :: String)
end

fun add-clip(name :: String, to :: XML.Element) -> XML.Element:
  XML.tag(to.name, to.attributes + [list: XML.attribute("clip-path",XML.atomic(name))], to.elts)
end

fun get-clip(i :: Image%(is-clipped-image), fit-all :: Boolean) -> ClipInfo:
  doc: "Returns the clip for the given clipped image"
  bbox = i.pair.get-box()
  shapes = draw-prerendered-svg(i.pair.bottom, fit-all)
  prefix = num-random(10000) # TODO: Find a better way to avoid n.s. collisions
  wrapped = for map2(n from range(0,shapes.length()), elt from shapes):
    wrap-and-name(prefix, n, elt)
  end
  defs = XML.tag("defs", empty, wrapped + get-clip-intersect(prefix, wrapped, bbox.width, bbox.height))
  to-use = defs.elts.last().attributes.first.value.val # That's a mouthful
  clip-pair(defs, "url(#" + to-use + ")")
end

fun draw-prerendered-svg(i :: Image, fit-all :: Boolean) -> List<XML.Element>:
  doc: "Returns the list of XML elements corresponding to the given pre-rendered image"
  cases(Image) i:
    | compound-image(top, at, bottom, pin) => 
      dy = if fit-all: num-max(0, bottom.snap-vec().get(1)) else: 0 end
      # basis needed for translating from relative positioning
      # to absolute positioning
      i-center = i.get-center()
      basis = bottom.coord-zero()
      top-basis = top.coord-zero()
      true-at = posn(at.x + basis.x, at.y + basis.y)
      pre-trans-top = top.translate([vector: (true-at.x - top.get-center().x), (true-at.y - top.get-center().y) + dy])
      top-vec = if fit-all: pre-trans-top.snap-vec() else: [vector: 0, 0] end
      top-dx = num-max(0, top-vec.first)
      top-dy = num-max(0, top-vec.get(1))
      mid-trans-top = pre-trans-top.translate([vector: top-dx, top-dy])
      mid-trans-bot = bottom.translate([vector: top-dx, dy + top-dy])
      mtrans-cb = mid-trans-top.cornerbox().join(mid-trans-bot.cornerbox())
      mtrans-center = mtrans-cb.get-center()
      center-vec = if fit-all: [vector: num-max(0, i-center.x - mtrans-center.x), num-max(0, i-center.y - mtrans-center.y)] else: [vector: 0, 0] end
      # print('[draw-prerendered-svg start]')
      # print('at            : ' + torepr(at))
      # print('pin           : ' + torepr(pin))
      # print('basis         : ' + torepr(basis))
      # print('true-at       : ' + torepr(true-at))
      # print('top-vec       : ' + torepr(top-vec))
      # print('top-dx        : ' + torepr(top-dx))
      # print('top-dy        : ' + torepr(top-dy))
      # print('mtrans-cb     : ' + torepr(mtrans-cb))
      # print('mtrans-center : ' + torepr(mtrans-center))
      # print('center-vec    : ' + torepr(center-vec))
      # print('[draw-prerendered-svg end]') 
      draw-prerendered-svg(mid-trans-bot.translate(center-vec), fit-all).append(
        draw-prerendered-svg(mid-trans-top.translate(center-vec), fit-all))
      
    | clipped-image(pair, hide-bottom) =>
      clip = get-clip(i, fit-all)
      clip-add = lam(e): add-clip(clip.useClip, e) end
      dy = if fit-all: num-max(0, pair.bottom.snap-vec().get(1)) else: 0 end
      basis = pair.bottom.coord-zero()
      true-at = posn(pair.at.x + basis.x, pair.at.y + basis.y)
      trans-top = pair.top.translate([vector: (true-at.x - pair.top.get-center().x), 
                                              (true-at.y - pair.top.get-center().y) + dy])
      if not(hide-bottom):
        [list: clip.defs] + map(clip-add, draw-prerendered-svg(pair.bottom.translate([vector: 0, dy]), fit-all).append(draw-prerendered-svg(trans-top, false)))
      else:
        [list: clip.defs] + map(clip-add, draw-prerendered-svg(trans-top, false))
      end
      
    | else =>
      if is-polygon(i):
        [list: draw-polygon(i)]
      else:
        [list: draw-bezier-shape(i)]
      end
  end
end

fun list-min<X>(lst :: List<X>) -> X:
  doc: "Returns the minimal element of the given list"
  retless = lam(a,b): if a < b: a else: b end end
  cases(List) lst:
    | link(_,_) => fold(retless, lst.first, lst.rest)
    | empty => raise("Cannot find the least element of an empty list")
  end
where:
  list-min([list: 4, 2, 6, 3, 7, 4, 1, 3, 8]) is 1
  list-min([list: -30, 2, 5, 2, 6]) is -30
end


fun draw-svg(i :: Image) -> XML.Element:
  doc: "Returns an SVG element representation of the given image"
  # Current status: Spits out <svg> tag in REPR. Copy/paste somewhere
  #   such as http://scriptdraw.com/ to view, or use a Tampermonkey
  #   script made by Philip (email (see top) for a copy)
  pre = draw-prerendered-svg(i, true) # Returns all <polygon> and <path> tags
  b = i.svg-size()
  ht = XML.attribute("height", num-exact(b.height))
  wd = XML.attribute("width", num-exact(b.width))
  i-pin = i.get-pinhole()
  ibox = i.get-box()
  maybe-pin-svg = if is-explicit-posn(i-pin): 
      svg-pinhole-lines(i-pin, ibox.width, ibox.height) 
    else:
      XML.tag("g", empty, empty)
    end
  attrs = 
  if ((is-polygon(i) or is-bezier-shape(i)) and (i.mode == outline)): 
    [list: wd, ht, XML.attribute("style", "overflow:visible;")]
  else:
    [list: wd, ht]
  end
  # Append to make sure that the pinhole is on top
  XML.tag("svg", attrs, pre.append([list: maybe-pin-svg]))
end

fun draw-debug(i :: Image) -> XML.Element:
  cb = i.cornerbox()
  #i-pin = i.get-pinhole()
  cb-as-box = cb.to-box()
  #pinhole-svg = svg-pinhole-lines(i-pin, cb-as-box.width, cb-as-box.height)
  shadow frame = raw-svg-rect(cb.top-left, cb-as-box.width, cb-as-box.height)
  center-dot = raw-svg-dot(i.get-center())
  cases(XML.Element) draw-svg(i):
    | tag(tname, attrs, pre) => XML.tag(tname, attrs, pre.append([list: frame, center-dot]))
  end
end
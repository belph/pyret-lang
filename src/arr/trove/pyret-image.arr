provide {
  rgba-color : IM_D.rgba-color,
  rgb-color : IM_D.rgb-color,
  orangered : IM_D.orangered,
  tomato : IM_D.tomato,
  darkred : IM_D.darkred,
  red : IM_D.red,
  firebrick : IM_D.firebrick,
  crimson : IM_D.crimson,
  deeppink : IM_D.deeppink,
  maroon : IM_D.maroon,
  indianred : IM_D.indianred,
  mediumvioletred : IM_D.mediumvioletred,
  violetred : IM_D.violetred,
  lightcoral : IM_D.lightcoral,
  hotpink : IM_D.hotpink,
  palevioletred : IM_D.palevioletred,
  lightpink : IM_D.lightpink,
  rosybrown : IM_D.rosybrown,
  pink : IM_D.pink,
  orchid : IM_D.orchid,
  lavenderblush : IM_D.lavenderblush,
  snow : IM_D.snow,
  chocolate : IM_D.chocolate,
  saddlebrown : IM_D.saddlebrown,
  brown : IM_D.brown,
  darkorange : IM_D.darkorange,
  coral : IM_D.coral,
  sienna : IM_D.sienna,
  orange : IM_D.orange,
  salmon : IM_D.salmon,
  peru : IM_D.peru,
  darkgoldenrod : IM_D.darkgoldenrod,
  goldenrod : IM_D.goldenrod,
  sandybrown : IM_D.sandybrown,
  lightsalmon : IM_D.lightsalmon,
  darksalmon : IM_D.darksalmon,
  gold : IM_D.gold,
  yellow : IM_D.yellow,
  olive : IM_D.olive,
  burlywood : IM_D.burlywood,
  tan : IM_D.tan,
  navajowhite : IM_D.navajowhite,
  peachpuff : IM_D.peachpuff,
  khaki : IM_D.khaki,
  darkkhaki : IM_D.darkkhaki,
  moccasin : IM_D.moccasin,
  wheat : IM_D.wheat,
  bisque : IM_D.bisque,
  palegoldenrod : IM_D.palegoldenrod,
  blanchedalmond : IM_D.blanchedalmond,
  mediumgoldenrod : IM_D.mediumgoldenrod,
  papayawhip : IM_D.papayawhip,
  mistyrose : IM_D.mistyrose,
  lemonchiffon : IM_D.lemonchiffon,
  antiquewhite : IM_D.antiquewhite,
  cornsilk : IM_D.cornsilk,
  lightgoldenrodyellow : IM_D.lightgoldenrodyellow,
  oldlace : IM_D.oldlace,
  linen : IM_D.linen,
  lightyellow : IM_D.lightyellow,
  seashell : IM_D.seashell,
  beige : IM_D.beige,
  floralwhite : IM_D.floralwhite,
  ivory : IM_D.ivory,
  green : IM_D.green,
  lawngreen : IM_D.lawngreen,
  chartreuse : IM_D.chartreuse,
  greenyellow : IM_D.greenyellow,
  yellowgreen : IM_D.yellowgreen,
  mediumforestgreen : IM_D.mediumforestgreen,
  olivedrab : IM_D.olivedrab,
  darkolivegreen : IM_D.darkolivegreen,
  darkseagreen : IM_D.darkseagreen,
  lime : IM_D.lime,
  darkgreen : IM_D.darkgreen,
  limegreen : IM_D.limegreen,
  forestgreen : IM_D.forestgreen,
  springgreen : IM_D.springgreen,
  mediumspringgreen : IM_D.mediumspringgreen,
  seagreen : IM_D.seagreen,
  mediumseagreen : IM_D.mediumseagreen,
  aquamarine : IM_D.aquamarine,
  lightgreen : IM_D.lightgreen,
  palegreen : IM_D.palegreen,
  mediumaquamarine : IM_D.mediumaquamarine,
  turquoise : IM_D.turquoise,
  lightseagreen : IM_D.lightseagreen,
  mediumturquoise : IM_D.mediumturquoise,
  honeydew : IM_D.honeydew,
  mintcream : IM_D.mintcream,
  royalblue : IM_D.royalblue,
  dodgerblue : IM_D.dodgerblue,
  deepskyblue : IM_D.deepskyblue,
  cornflowerblue : IM_D.cornflowerblue,
  steelblue : IM_D.steelblue,
  lightskyblue : IM_D.lightskyblue,
  darkturquoise : IM_D.darkturquoise,
  cyan : IM_D.cyan,
  aqua : IM_D.aqua,
  darkcyan : IM_D.darkcyan,
  teal : IM_D.teal,
  skyblue : IM_D.skyblue,
  cadetblue : IM_D.cadetblue,
  darkslategray : IM_D.darkslategray,
  lightslategray : IM_D.lightslategray,
  slategray : IM_D.slategray,
  lightsteelblue : IM_D.lightsteelblue,
  lightblue : IM_D.lightblue,
  powderblue : IM_D.powderblue,
  paleturquoise : IM_D.paleturquoise,
  lightcyan : IM_D.lightcyan,
  aliceblue : IM_D.aliceblue,
  azure : IM_D.azure,
  mediumblue : IM_D.mediumblue,
  darkblue : IM_D.darkblue,
  midnightblue : IM_D.midnightblue,
  navy : IM_D.navy,
  blue : IM_D.blue,
  indigo : IM_D.indigo,
  blueviolet : IM_D.blueviolet,
  mediumslateblue : IM_D.mediumslateblue,
  slateblue : IM_D.slateblue,
  purple : IM_D.purple,
  darkslateblue : IM_D.darkslateblue,
  darkviolet : IM_D.darkviolet,
  darkorchid : IM_D.darkorchid,
  mediumpurple : IM_D.mediumpurple,
  mediumorchid : IM_D.mediumorchid,
  magenta : IM_D.magenta,
  fuchsia : IM_D.fuchsia,
  darkmagenta : IM_D.darkmagenta,
  violet : IM_D.violet,
  plum : IM_D.plum,
  lavender : IM_D.lavender,
  thistle : IM_D.thistle,
  ghostwhite : IM_D.ghostwhite,
  white : IM_D.white,
  whitesmoke : IM_D.whitesmoke,
  gainsboro : IM_D.gainsboro,
  lightgray : IM_D.lightgray,
  silver : IM_D.silver,
  gray : IM_D.gray,
  grey : IM_D.grey,
  darkgray : IM_D.darkgray,
  dimgray : IM_D.dimgray,
  black : IM_D.black,
  outline : IM_D.outline,
  solid : IM_D.solid,
  x-left : IM_D.x-left,
  x-center : IM_D.x-center,
  x-right : IM_D.x-right,
  y-top : IM_D.y-top,
  y-center : IM_D.y-center,
  y-bottom : IM_D.y-bottom,
  posn : IM_AUX_DATA.posn,
  box : IM_AUX_DATA.box,
  ivl : IM_AUX_DATA.ivl,
  vector-sub : IM_MTX.vector-sub,
  points-bounding-box : IM_MTX.points-bounding-box,
  list-of-points-bounding-box : IM_MTX.list-of-points-bounding-box,
  mtx-center : IM_MTX.mtx-center,
  translate : IM_MTX.translate,
  translate-posn : IM_MTX.translate-posn,
  trans-mtx : IM_MTX.trans-mtx,
  homogeneous-transform : IM_MTX.homogeneous-transform,
  transform-posn : IM_MTX.transform-posn,
  transform-posn-about : IM_MTX.transform-posn-about,
  affine-transform-matrix : IM_MTX.affine-transform-matrix,
  matrix-to-posns : IM_MTX.matrix-to-posns,
  matrices-to-posns : IM_MTX.matrices-to-posns,
  bezier-box : IM_MTX.bezier-box,
  bezier-snap-trans : IM_MTX.bezier-snap-trans,
  cornerbox : IM_MTX.cornerbox,
  bez-corner-box : IM_MTX.bez-corner-box,
  poly-corner-box : IM_MTX.poly-corner-box,
  circle : circle,
  ellipse : ellipse,
  line : line,
  make-text : make-text,
  make-text-font : make-text-font,
  triangle : triangle,
  right-triangle : right-triangle,
  isosceles-triangle : isosceles-triangle,
  triangle-sss : triangle-sss,
  triangle-ass : triangle-ass,
  triangle-sas : triangle-sas,
  triangle-ssa : triangle-ssa,
  triangle-aas : triangle-aas,
  triangle-asa : triangle-asa,
  triangle-saa : triangle-saa,
  square : square,
  rectangle : rectangle,
  rhombus : rhombus,
  star : star,
  radial-star : radial-star,
  star-sized : star-sized,
  star-polygon : star-polygon,
  regular-polygon : regular-polygon,
  empty-image : empty-image,
  overlay : overlay,
  overlay-pinhole : overlay-pinhole,
  overlay-align : overlay-align,
  overlay-offset : overlay-offset,
  overlay-align-offset : overlay-align-offset,
  overlay-xy : overlay-xy,
  underlay : underlay,
  underlay-pinhole : underlay-pinhole,
  underlay-align : underlay-align,
  underlay-offset : underlay-offset,
  underlay-align-offset : underlay-align-offset,
  underlay-xy : underlay-xy,
  beside : beside,
  beside-list : beside-list,
  beside-align : beside-align,
  beside-align-list : beside-align-list,
  above : above,
  above-list : above-list,
  above-align : above-align,
  above-align-list : above-align-list,
  empty-scene : empty-scene,
  colored-empty-scene : colored-empty-scene,
  place-image : place-image,
  place-images : place-images,
  place-image-align : place-image-align,
  frame : frame,
  draw-svg : draw-svg
} end
provide-types *


#import matrix, vector from shared-gdrive("matrices_3", "0ByJ_bK5RkycfSVZTRFd5QUpzaWc")
#import shared-gdrive("matrices_3", "0ByJ_bK5RkycfSVZTRFd5QUpzaWc") as M
#import shared-gdrive("XML", "0ByJ_bK5RkycfbE8zNF81SVBEcUE") as XML
#import shared-gdrive("image_datatypes", "0ByJ_bK5RkycfUURMNTk1X3JYd2s") as IM_D
#import shared-gdrive("image_auxiliary_datatypes", "0ByJ_bK5RkycfNEd0WGJ5eFc3RE0") as IM_AUX_DATA
#import shared-gdrive("image_matrix_helpers", "0ByJ_bK5RkycfWks5alRZNk42TVk") as IM_MTX
#import matrix, vector from "matrices.arr"
#import "matrices.arr" as M
#import "XML.arr" as XML
#import "image_datatypes.arr" as IM_D
#import "image_auxiliary_datatypes.arr" as IM_AUX_DATA
#import "image_matrix_helpers.arr" as IM_MTX
import matrix, vector from matrices
import matrices as M
import xml as XML
import image_datatypes as IM_D
import image_auxiliary_datatypes as IM_AUX_DATA
import image_matrix_helpers as IM_MTX
import Equal, NotEqual from equality


pi = 2 * num-asin(1)

fun to-radians(theta :: Number):
  doc: "Converts the given angle from degrees into radians"
  (theta * pi) * (1 / 180)
end

fun to-degrees(theta :: Number):
  doc: "Converts the given angle from radians into degrees"
  (theta * 180) / pi
end

#########################
# PYRET IMAGE DATATYPES #
#########################

### CONSTANTS
DEFAULT_OUTLINE_WIDTH = 2
OUTLINE_FIX_VEC = [vector: (1/2 * DEFAULT_OUTLINE_WIDTH), (1/2 * DEFAULT_OUTLINE_WIDTH)]

### USED PREDICATES



# greater-than-zero
# Predicate to make sure that the
#   given number is larger than 0.
fun greater-than-zero(n :: Number) -> Boolean:
  0 < n
end

# nonzero-nat
# Predicate to check if the
#   given number is a Natural
#   number greater than 0.
fun nonzero-nat(n :: Number) -> Boolean:
  (0 < n) and num-is-integer(n)
end

matrix2d = lam(m): m.rows == 2 end

### DATA DEFINITIONS

type Color = IM_D.Color
type Mode = IM_D.Mode
type X-Place = IM_D.X-Place
type Y-Place = IM_D.Y-Place

rgba-color = IM_D.rgba-color
rgb-color = IM_D.rgb-color
orangered = IM_D.orangered
tomato = IM_D.tomato
darkred = IM_D.darkred
red = IM_D.red
firebrick = IM_D.firebrick
crimson = IM_D.crimson
deeppink = IM_D.deeppink
maroon = IM_D.maroon
indianred = IM_D.indianred
mediumvioletred = IM_D.mediumvioletred
violetred = IM_D.violetred
lightcoral = IM_D.lightcoral
hotpink = IM_D.hotpink
palevioletred = IM_D.palevioletred
lightpink = IM_D.lightpink
rosybrown = IM_D.rosybrown
pink = IM_D.pink
orchid = IM_D.orchid
lavenderblush = IM_D.lavenderblush
snow = IM_D.snow
chocolate = IM_D.chocolate
saddlebrown = IM_D.saddlebrown
brown = IM_D.brown
darkorange = IM_D.darkorange
coral = IM_D.coral
sienna = IM_D.sienna
orange = IM_D.orange
salmon = IM_D.salmon
peru = IM_D.peru
darkgoldenrod = IM_D.darkgoldenrod
goldenrod = IM_D.goldenrod
sandybrown = IM_D.sandybrown
lightsalmon = IM_D.lightsalmon
darksalmon = IM_D.darksalmon
gold = IM_D.gold
yellow = IM_D.yellow
olive = IM_D.olive
burlywood = IM_D.burlywood
tan = IM_D.tan
navajowhite = IM_D.navajowhite
peachpuff = IM_D.peachpuff
khaki = IM_D.khaki
darkkhaki = IM_D.darkkhaki
moccasin = IM_D.moccasin
wheat = IM_D.wheat
bisque = IM_D.bisque
palegoldenrod = IM_D.palegoldenrod
blanchedalmond = IM_D.blanchedalmond
mediumgoldenrod = IM_D.mediumgoldenrod
papayawhip = IM_D.papayawhip
mistyrose = IM_D.mistyrose
lemonchiffon = IM_D.lemonchiffon
antiquewhite = IM_D.antiquewhite
cornsilk = IM_D.cornsilk
lightgoldenrodyellow = IM_D.lightgoldenrodyellow
oldlace = IM_D.oldlace
linen = IM_D.linen
lightyellow = IM_D.lightyellow
seashell = IM_D.seashell
beige = IM_D.beige
floralwhite = IM_D.floralwhite
ivory = IM_D.ivory
green = IM_D.green
lawngreen = IM_D.lawngreen
chartreuse = IM_D.chartreuse
greenyellow = IM_D.greenyellow
yellowgreen = IM_D.yellowgreen
mediumforestgreen = IM_D.mediumforestgreen
olivedrab = IM_D.olivedrab
darkolivegreen = IM_D.darkolivegreen
darkseagreen = IM_D.darkseagreen
lime = IM_D.lime
darkgreen = IM_D.darkgreen
limegreen = IM_D.limegreen
forestgreen = IM_D.forestgreen
springgreen = IM_D.springgreen
mediumspringgreen = IM_D.mediumspringgreen
seagreen = IM_D.seagreen
mediumseagreen = IM_D.mediumseagreen
aquamarine = IM_D.aquamarine
lightgreen = IM_D.lightgreen
palegreen = IM_D.palegreen
mediumaquamarine = IM_D.mediumaquamarine
turquoise = IM_D.turquoise
lightseagreen = IM_D.lightseagreen
mediumturquoise = IM_D.mediumturquoise
honeydew = IM_D.honeydew
mintcream = IM_D.mintcream
royalblue = IM_D.royalblue
dodgerblue = IM_D.dodgerblue
deepskyblue = IM_D.deepskyblue
cornflowerblue = IM_D.cornflowerblue
steelblue = IM_D.steelblue
lightskyblue = IM_D.lightskyblue
darkturquoise = IM_D.darkturquoise
cyan = IM_D.cyan
aqua = IM_D.aqua
darkcyan = IM_D.darkcyan
teal = IM_D.teal
skyblue = IM_D.skyblue
cadetblue = IM_D.cadetblue
darkslategray = IM_D.darkslategray
lightslategray = IM_D.lightslategray
slategray = IM_D.slategray
lightsteelblue = IM_D.lightsteelblue
lightblue = IM_D.lightblue
powderblue = IM_D.powderblue
paleturquoise = IM_D.paleturquoise
lightcyan = IM_D.lightcyan
aliceblue = IM_D.aliceblue
azure = IM_D.azure
mediumblue = IM_D.mediumblue
darkblue = IM_D.darkblue
midnightblue = IM_D.midnightblue
navy = IM_D.navy
blue = IM_D.blue
indigo = IM_D.indigo
blueviolet = IM_D.blueviolet
mediumslateblue = IM_D.mediumslateblue
slateblue = IM_D.slateblue
purple = IM_D.purple
darkslateblue = IM_D.darkslateblue
darkviolet = IM_D.darkviolet
darkorchid = IM_D.darkorchid
mediumpurple = IM_D.mediumpurple
mediumorchid = IM_D.mediumorchid
magenta = IM_D.magenta
fuchsia = IM_D.fuchsia
darkmagenta = IM_D.darkmagenta
violet = IM_D.violet
plum = IM_D.plum
lavender = IM_D.lavender
thistle = IM_D.thistle
ghostwhite = IM_D.ghostwhite
white = IM_D.white
whitesmoke = IM_D.whitesmoke
gainsboro = IM_D.gainsboro
lightgray = IM_D.lightgray
silver = IM_D.silver
gray = IM_D.gray
grey = IM_D.grey
darkgray = IM_D.darkgray
dimgray = IM_D.dimgray
black = IM_D.black
outline = IM_D.outline
solid = IM_D.solid
x-left = IM_D.x-left
x-center = IM_D.x-center
x-right = IM_D.x-right
y-top = IM_D.y-top
y-center = IM_D.y-center
y-bottom = IM_D.y-bottom

type Position = IM_AUX_DATA.Position
type Box = IM_AUX_DATA.Box
type Interval = IM_AUX_DATA.Interval

posn = IM_AUX_DATA.posn
box = IM_AUX_DATA.box
ivl = IM_AUX_DATA.ivl

vector-sub = IM_MTX.vector-sub
points-bounding-box = IM_MTX.points-bounding-box
list-of-points-bounding-box = IM_MTX.list-of-points-bounding-box
mtx-center = IM_MTX.mtx-center
translate = IM_MTX.translate
translate-posn = IM_MTX.translate-posn
trans-mtx = IM_MTX.trans-mtx
homogeneous-transform = IM_MTX.homogeneous-transform
transform-posn = IM_MTX.transform-posn
transform-posn-about = IM_MTX.transform-posn-about
affine-transform-matrix = IM_MTX.affine-transform-matrix
matrix-to-posns = IM_MTX.matrix-to-posns
matrices-to-posns = IM_MTX.matrices-to-posns
bezier-box = IM_MTX.bezier-box
bezier-snap-trans = IM_MTX.bezier-snap-trans

type CornerBox = IM_MTX.CornerBox
cornerbox = IM_MTX.cornerbox
bez-corner-box = IM_MTX.bez-corner-box
poly-corner-box = IM_MTX.poly-corner-box

  

# Transformation Matrices Definitions

fun rotation-matrix(theta-deg :: Number) -> M.Matrix:
  doc: "Returns a rotation matrix for the given counterclockwise angle"
  theta = to-radians(theta-deg)
  [matrix(2,2): num-cos(theta), (-1 * num-sin(theta)),
    num-sin(theta), num-cos(theta)]
end

fun scale-xy-matrix(xk :: Number, yk :: Number) -> M.Matrix:
  doc: "Returns an xy-scaling matrix for the given scales"
  [matrix(2,2): xk, 0, 0, yk]
end

fun scale-x-matrix(k :: Number) -> M.Matrix:
  doc: "Returns an x-scaling matrix for the given scale"
  scale-xy-matrix(k, 1)
end

fun scale-y-matrix(k :: Number) -> M.Matrix:
  doc: "Returns a y-scaling matrix for the given scale"
  scale-xy-matrix(1, k)
end

fun scale-matrix(k :: Number) -> M.Matrix:
  doc: "Returns a scaling matrix for the given amount"
  scale-xy-matrix(k, k)
end


flip-horiz-matrix = [matrix(2,2): 1, 0, 0, -1]

flip-vert-matrix = [matrix(2,2): -1, 0, 0, 1]

#Datatype helpers

fun snap-row-trans(img :: List<List<Number>>) -> M.Vector:
  doc: "Returns the vector needed to snap the given list of points to the bounds of the first quadrant"
  min-x = img.first.map(num-exact).sort().first
  min-y = img.get(1).map(num-exact).sort().first
  trans-x = if (min-x < 0):
    num-abs(min-x)
  else:
    -1 * min-x
  end
  trans-y = if (min-y < 0):
    num-abs(min-y)
  else:
    -1 * min-y
  end
  [vector: trans-x, trans-y]
end

fun new-box(i1 :: Image, x :: Number, y :: Number, i2 :: Image, i1-pinhole :: Position) -> Box:
  doc: "Returns the new box of the first image placed on the second at the given position"
  top-shift-x = x - (i1-pinhole.x)
  top-shift-y = y - (i1-pinhole.y)
  i1.translate([vector: top-shift-x, top-shift-y]).cornerbox().join(i2.cornerbox()).to-box()
end

fun new-svg-size(i1 :: Image, x :: Number, y :: Number, i2 :: Image, i1-pinhole :: Position) -> Box:
  doc: "Returns the new svg canvas size of the first image placed on the second at the given position"
  top-box = i1.get-box()
  top-svg = i1.svg-size()
  top-shift-x = x + ((top-box.width / 2) - i1-pinhole.x)
  top-shift-y = y + ((top-box.height / 2) - i1-pinhole.y)
  top-x = ivl(0,(top-svg.width)).shift(top-shift-x)
  top-y = ivl(0,(top-svg.height)).shift(top-shift-y)
  bottom-svg = i2.svg-size()
  box-x = ivl(0,bottom-svg.width).comb(top-x).len()
  box-y = ivl(0,bottom-svg.height).comb(top-y).len()
  box(box-x,box-y)
end

fun clip-box(i1 :: Image, x :: Number, y :: Number, i2 :: Image, i1-pinhole :: Position) -> Box:
  doc: "Returns the size of the first image's box (placed at the given position) clipped to the second's"
  top-box = i1.get-box()
  top-shift-x = x + ((top-box.width / 2) - i1-pinhole.x)
  top-shift-y = y + ((top-box.height / 2) - i1-pinhole.y)
  top-x = ivl((-1 * (top-box.width / 2)),(top-box.width / 2)).shift(top-shift-x)
  top-y = ivl((-1 * (top-box.height / 2)),(top-box.height / 2)).shift(top-shift-y)
  bottom-box = i2.get-box()
  box-x = ivl(0,bottom-box.width).intersect(top-x).len()
  box-y = ivl(0,bottom-box.height).intersect(top-y).len()
  box(box-x,box-y)
end


  

# The Image Data Type

# IMAGE DATATYPE LAYOUT:
# - Primitives (circle, star, square, etc.)
#    + Same as 2htdp library
# - Compound Image
#    + A Binary Tree datatype which represents
#        one image on top of another, centered
#        at the given point
# - Orthoganally Transformed Images (rotation, reflection)
#    + Represents an image with a size-preserving
#        transformation



data Image:
  # text()
  # Represents the given string
  #   of text, using the given
  #   font size and color
  | text(string :: String,
         size   :: Number%(greater-than-zero),
         color  :: Color,
      center   :: Position)
    
  # text-font()
  # Represents the given string
  #   of text with the given font
  #   specification
  | text-font(string      :: String,
              size        :: Number%(greater-than-zero),
              color       :: Color,
              font-face   :: String, #TODO: Font Face datatype?
              font-family :: String, #TODO: Font Family datatype?
              style       :: String,
              weight      :: String,
              underline   :: Boolean,
      center   :: Position)
  | polygon(matrix :: M.Matrix,
      mode :: Mode,
      color :: Color,
      center :: Position
      ) with:
    to-matrix(self): self.matrix end,
    get-box(self): 
      cases(Mode) self.mode:
        | solid => points-bounding-box(self.matrix)
        | outline =>
          base-box = points-bounding-box(self.matrix)
          base-box
          # By default, half of the outline is cut off
          #box(base-box.width + DEFAULT_OUTLINE_WIDTH, base-box.height + DEFAULT_OUTLINE_WIDTH)
      end 
    end,
    
    translate(self, v :: M.Vector) -> Image: 
      polygon(translate(self.matrix,v),self.mode,self.color,translate-posn(self.center,v))
    end,
    
    transform(self, mtx :: M.Matrix) -> Image:
      polygon(homogeneous-transform(mtx,self.matrix),
        self.mode,self.color,transform-posn(mtx,self.center))
    end,
    
    affine-transform-about(self, transformation :: M.Matrix%(matrix2d), abt :: Position) -> Image:
      doc: "Performs an affine transformation of the image about the given point"
      self.translate([vector: (-1 * abt.x), (-1 * abt.y)] ).transform(transformation).translate([vector: abt.x, abt.y])
    end,
    
    affine-transform(self, transformation :: M.Matrix%(matrix2d)) -> Image:
      self.affine-transform-about(transformation,self.center)
    end,
    
    snap-vec(self):
      snap-row-trans(self.matrix.to-lists())
    end,
    
    snap-axes(self):
      cases(Mode) self.mode:
        | solid => self.translate(snap-row-trans(self.matrix.to-lists()))
        | outline => self.translate(snap-row-trans(self.matrix.to-lists()))#.translate( OUTLINE_FIX_VEC)
      end
    end,
    
    new-color(self, k :: Color) -> Image:
      polygon(self.matrix, self.mode, k, self.center)
    end,
    
    mtx-list(self) -> List<List<Number>>:
      self.matrix.to-lists()
    end,
    
    svg-size(self) -> Box:
      cornerbox(posn(0,0),self.cornerbox().bottom-right).to-box()
    end,
    
    put-pinhole(self, phx :: Number, phy :: Number) -> Image:
      polygon(self.matrix, self.mode, self.color, posn(phx,phy))
    end,
    
    remove-pinhole(self) -> Image:
      sbb = self.get-box()
      polygon(self.matrix, self.mode, self.color, posn(sbb.width / 2, sbb.height / 2))
    end,
    
    cornerbox(self) -> CornerBox:
      poly-corner-box(self.mtx-list())
    end
    
#    equalTo(self, a :: Image%(is-polygon), eq):
#      if (self.matrix == a.matrix):
#        if (self.mode == a.mode):
#          if (self.color == a.color):
#            if (self.center == a.center):
#              Equal
#            else:
#              NotEqual("Image pinholes differ")
#            end
#          else:
#            NotEqual("Image colors differ")
#          end
#        else:
#          NotEqual("Image modes differ")
#        end
#      else:
#        NotEqual("Images are of different shapes")
#      end
#    end,
    
#    _equals(self, a :: Image %(is-polygon), eq):
#      self.equalTo(a,eq)
#    end
          
    
  | bezier-shape(matrix :: M.Matrix,
      mode :: Mode,
      color :: Color,
      center :: Position
      ) with:
    to-matrix(self): self.matrix end,
    get-box(self): 
      cases(Mode) self.mode:
        | solid => bezier-box(matrix-to-posns(self.matrix)) 
        | outline =>
          base-box = bezier-box(matrix-to-posns(self.matrix))
          base-box
          #box(base-box.width + (2 * DEFAULT_OUTLINE_WIDTH), base-box.height + (2 * DEFAULT_OUTLINE_WIDTH))
      end
    end,
    
    translate(self, v :: M.Vector) -> Image: 
      bezier-shape(translate(self.matrix,v),self.mode,self.color,translate-posn(self.center,v))
    end,
    
    transform(self, mtx :: M.Matrix) -> Image:
      bezier-shape(homogeneous-transform(mtx,self.matrix),
        self.mode,self.color,transform-posn(mtx,self.center))
    end,
    
    affine-transform-about(self, transformation :: M.Matrix%(matrix2d), abt :: Position) -> Image:
      doc: "Performs an affine transformation of the image about the given point"
      self.translate([vector: (-1 * abt.x), (-1 * abt.y)] ).transform(transformation).translate([vector: abt.x, abt.y])
    end,
    
    affine-transform(self, transformation :: M.Matrix%(matrix2d)) -> Image:
      self.affine-transform-about(transformation,self.center)
    end,
    
    snap-vec(self):
      bezier-snap-trans(matrix-to-posns(self.matrix))
    end,
    
    snap-axes(self):
      cases(Mode) self.mode:
        | solid => self.translate(bezier-snap-trans(matrix-to-posns(self.matrix)))
        | outline => self.translate(bezier-snap-trans(matrix-to-posns(self.matrix)))#.translate( OUTLINE_FIX_VEC)
      end
    end,
    
    new-color(self, k :: Color) -> Image:
      bezier-shape(self.matrix, self.mode, k, self.center)
    end,
    
    mtx-list(self) -> List<List<Number>>:
      self.matrix.to-lists()
    end,
    
    svg-size(self) -> Box:
      cornerbox(posn(0,0),self.cornerbox().bottom-right).to-box()
    end,
    
    put-pinhole(self, phx :: Number, phy :: Number) -> Image:
      bezier-shape(self.matrix, self.mode, self.color, posn(phx,phy))
    end,
    
    remove-pinhole(self) -> Image:
      sbb = self.get-box()
      bezier-shape(self.matrix, self.mode, self.color, posn(sbb.width / 2, sbb.height / 2))
    end,
    
    cornerbox(self) -> CornerBox:
      bez-corner-box(matrix-to-posns(self.matrix))
    end
    
    
  | compound-image(top    :: Image,
                   at     :: Position,
                   bottom :: Image,
      center   :: Position
      ) with:
    get-box(self):
      if (is-clipped-image(self.top)):
        new-box(self.top,self.at.x,self.at.y,self.bottom,self.top.pair.center)
      else:
        new-box(self.top,self.at.x,self.at.y,self.bottom, self.top.center)
      end
    end,
    
    translate(self, v :: M.Vector) -> Image: 
      compound-image(self.top.translate(v), self.at, self.bottom.translate(v), translate-posn(self.center, v))
    end,
    
    #transform(self, mtx :: M.Matrix) -> Image:
      
    #end,
    
    affine-transform(self, transformation :: M.Matrix%(matrix2d)) -> Image:
      ti = self.top.affine-transform-about(transformation,self.center).snap-axes()
      bi = self.bottom.affine-transform-about(transformation,self.center).snap-axes()
      ob = self.get-box()
      old-bottom = self.bottom.get-box()
      new-bottom = bi.get-box()
      relpos = posn(self.center.x / ob.width, self.center.y / ob.height)
      new-at = posn((self.at.x * new-bottom.width) / old-bottom.width, (self.at.y * new-bottom.height) / old-bottom.height)
      nb = new-box(ti,new-at.x, new-at.y,bi, ti.center)
      new-c = posn(relpos.x * nb.width, relpos.y * nb.height)
      #new-c = transform-posn-about(transformation, self.center, self.center)
      #new-at = posn(self.at.x + (new-c.x - self.center.x),self.at.y + (new-c.y - self.center.y))
      compound-image(ti, new-at, bi, new-c)
      
      #compound-image(self.top.translate([vector: (-1 * self.center.x), (-1 * self.center.y)] ).affine-transform(transformation).translate([vector: self.center.x, self.center.y]), self.at,
       # self.bottom.translate([vector: (-1 * self.center.x), (-1 * self.center.y)] ).affine-transform(transformation).translate([vector: self.center.x, self.center.y]),self.center)
    end,
    
    snap-vec(self):
      t-trans = cases(Image) self.top:
        | polygon(_,_,_,_) => 
          if (self.top.mode == solid):
            snap-row-trans(self.top.mtx-list())
          else:
            snap-row-trans(self.top.mtx-list())
            #vector-sub(snap-row-trans(self.top.mtx-list()), OUTLINE_FIX_VEC)
          end
        | bezier-shape(_,_,_,_) =>
          if (self.top.mode == solid):
            bezier-snap-trans(matrix-to-posns(self.top.matrix))
          else:
            bezier-snap-trans(matrix-to-posns(self.top.matrix))
            #vector-sub(bezier-snap-trans(matrix-to-posns(self.top.matrix)), OUTLINE_FIX_VEC)
          end
        | compound-image(_,_,_,_) =>
          self.top.snap-vec()
        | clipped-image(_,_) => self.top.snap-vec()
        | else => raise("Not yet implemented")
      end
      b-trans = cases(Image) self.bottom:
        | polygon(_,_,_,_) => 
          if (self.bottom.mode == solid):
            snap-row-trans(self.bottom.mtx-list())
          else:
            snap-row-trans(self.bottom.mtx-list())
            #vector-sub(snap-row-trans(self.bottom.mtx-list()), OUTLINE_FIX_VEC)
          end
        | bezier-shape(_,_,_,_) =>
          if (self.bottom.mode == solid):
            bezier-snap-trans(matrix-to-posns(self.bottom.matrix))
          else:
            bezier-snap-trans(matrix-to-posns(self.bottom.matrix))
            #vector-sub(bezier-snap-trans(matrix-to-posns(self.bottom.matrix)), OUTLINE_FIX_VEC)
          end
        | compound-image(_,_,_,_) =>
          self.bottom.snap-vec()
        | clipped-image(_,_) => self.bottom.snap-vec()
        | else => raise("Not yet implemented")
      end
      [vector: num-max(t-trans.get(0),b-trans.get(0)),num-max(t-trans.get(1),b-trans.get(1))]
    end,
    
    snap-axes(self):
      self.translate(self.snap-vec())
    end,
    
    new-color(self, k :: Color) -> Image:
      compound-image(self.top.new-color(k), self.at, self.bottom.new-color(k), self.center)
    end,
    
    mtx-list(self) -> List<List<Number>>:
      t = self.top.mtx-list()
      b = self.bottom.mtx-list()
      [list: t.first.append(b.first), t.get(1).append(b.get(1))]
    end,
    
    svg-size(self) -> Box:
      #if (is-clipped-image(self.top)):
      #  new-svg-size(self.top,self.at.x,self.at.y,self.bottom,self.top.pair.center)
      #else:
      #  new-svg-size(self.top,self.at.x,self.at.y,self.bottom, self.top.center)
      #end
      self.get-box() # Looking at the code for new-box(), it already works
    end,
    
    put-pinhole(self, phx :: Number, phy :: Number) -> Image:
      compound-image(self.top, self.at, self.bottom, posn(phx,phy))
    end,
    
    remove-pinhole(self) -> Image:
      sbb = self.get-box()
      compound-image(self.top, self.at, self.bottom, posn(sbb.width / 2, sbb.height / 2))
    end,
    
    cornerbox(self) -> CornerBox:
      self.top.cornerbox().join(self.bottom.cornerbox())
    end
    
    
    # Represents an image where the top of the compound image is clipped to the bottom
  | clipped-image(pair :: Image%(is-compound-image),
      hidden-mask :: Boolean) #If true, the bottom image is simply used as a clipping mask,
                            # as opposed to being a background 
                            # which the top is clipped to
    with:
    get-box(self):
      if self.hidden-mask:
        clip-box(self.pair.top, self.pair.at.x, self.pair.at.y, self.pair.bottom, self.pair.top.center)
      else:
        self.pair.bottom.get-box()
      end
    end,
    
    translate(self, v :: M.Vector) -> Image:
      clipped-image(self.pair.translate(v), self.hidden-mask)
    end,
    
    affine-transform(self, transformation :: M.Matrix%(matrix2d)) -> Image:
      clipped-image(self.pair.affine-transform(transformation),self.hidden-mask)
    end,
    
    snap-vec(self) -> M.Vector:
      self.pair.snap-vec()
    end,
    
    snap-axes(self) -> Image:
      clipped-image(self.pair.snap-axes(),self.hidden-mask)
    end,
    
    new-color(self, k :: Color) -> Image:
      clipped-image(self.pair.new-color(k),self.hidden-mask)
    end,
    
    hide-mask(self) -> Image:
      clipped-image(self.pair,true)
    end,
    
    show-mask(self) -> Image:
      clipped-image(self.pair,false)
    end,
    
    mtx-list(self) -> List<List<Number>>:
      self.pair.bottom.mtx-list()
    end,
    
    svg-size(self) -> Box:
      self.pair.bottom.svg-size()
    end,
    
    put-pinhole(self, phx :: Number, phy :: Number) -> Image:
      clipped-image(self.pair.put-pinhole(phx,phy), self.hidden-mask)
    end,
    
    remove-pinhole(self) -> Image:
      new-c = self.pair.bottom.remove-pinhole().center
      clipped-image(compound-image(self.pair.top, self.pair.at, self.pair.bottom, new-c), self.hidden-mask)
    end,
    
    cornerbox(self) -> CornerBox:
      if self.hidden-mask:
        self.pair.top.cornerbox().intersect(self.pair.bottom.cornerbox())
      else:
        self.pair.bottom.cornerbox()
      end
    end
    
sharing:
    
  flip-horizontal(self):
    self.affine-transform(flip-horiz-matrix).snap-axes()
  end,
  flip-vertical(self):
    self.affine-transform(flip-vert-matrix).snap-axes()
  end,
  scale-x(self, k :: Number):
    self.affine-transform(scale-x-matrix(k)).snap-axes()
  end,
  scale-y(self, k :: Number):
    self.affine-transform(scale-y-matrix(k)).snap-axes()
  end,
  scale-xy(self, xk :: Number, yk :: Number):
    self.affine-transform(scale-xy-matrix(xk,yk)).snap-axes()
  end,
  scale(self, k :: Number):
    self.affine-transform(scale-matrix(k)).snap-axes()
  end,
  rotate(self, theta :: Number):
    self.affine-transform(rotation-matrix(theta)).snap-axes()
  end,
  crop(self, x :: Number, y :: Number, width :: Number, height :: Number):
    doc: "Crops the image to a rectangle of the given width and height and its top-left corner at the given (x,y) position"
    self-bb = self.get-box()
    at = posn((self-bb.width / 2) - x, (self-bb.height / 2) - y)
    clipped-image(compound-image(self,at, rectangle(width,height,outline,black),posn((width / 2), (height / 2))),true)
  end,
  crop-align(self, xp :: X-Place, yp :: Y-Place, width :: Number, height :: Number):
    doc: "Crops the image to a rectangle of the given width and height placed at the given alignment"
    self-bb = self.get-box()
    at = posn(cases(X-Place) xp:
        | x-left => (self-bb.width / 2)
        | x-center => (width / 2)
        | x-right => (width) - (self-bb.width / 2)
      end, cases(Y-Place) yp:
        | y-top => (self-bb.height / 2)
        | y-center => (height / 2)
        | y-bottom => (height) - (self-bb.height / 2)
      end)
    clipped-image(compound-image(self, at, rectangle(width,height,outline,black),posn(width / 2, height / 2)), true)
  end,
  width(self) -> Number:
    doc: "Returns the image's width"
    self.get-box().width
  end,
  height(self) -> Number:
    doc: "Returns the image's height"
    self.get-box().height
  end,
  coord-zero(self) -> Position:
    doc: "Returns the position of the top-left corner of the image"
    self.cornerbox().top-left
  end
#  end,
#  _torepr(self, shadow torepr):
#    torepr(draw-svg(self))
#  end

end

#####################
## IMAGE CONSTRUCTORS
#####################

fun circle(radius :: Number, mode :: Mode, color :: Color):
  circ-const = 4/3 * (num-sqrt(2) - 1)
  r = radius
  rc = r * circ-const
  cx = radius
  cy = radius
  arc1 = [matrix(2,4): 0, rc, r, r,
    (-1 * r), (-1 * r), (-1 * rc), 0]
  arc2 = [matrix(2,3):  r, rc, 0,
    rc, r, r]
  arc3 = [matrix(2,3):  (-1 * rc), (-1 * r), (-1 * r),
    r, rc, 0]
  arc4 = [matrix(2,3):  (-1 * r), (-1 * rc), 0,
    (-1 * rc), (-1 * r), (-1 * r)]
  
  mtx = translate(arc1.augment(arc2).augment(arc3).augment(arc4),[vector: cx, cy])
  bezier-shape(mtx, mode, color, posn(radius, radius)).snap-axes()
end

fun ellipse(width  :: Number%(greater-than-zero),
    height :: Number%(greater-than-zero),
    mode   :: Mode,
    color  :: Color) :
  circ-const = 4/3 * (num-sqrt(2) - 1)
  rx = width / 2
  ry = height / 2
  rxc = rx * circ-const
  ryc = ry * circ-const
  cx = rx
  cy = ry
  arc1 = [matrix(2,4): 0, rxc, rx, rx,
    (-1 * ry), (-1 * ry), (-1 * ryc), 0]
  arc2 = [matrix(2,3):  rx, rxc, 0,
    ryc, ry, ry]
  arc3 = [matrix(2,3):  (-1 * rxc), (-1 * rx), (-1 * rx),
    ry, ryc, 0]
  arc4 = [matrix(2,3):  (-1 * rx), (-1 * rxc), 0,
    (-1 * ryc), (-1 * ry), (-1 * ry)]
      
  mtx = translate(arc1.augment(arc2).augment(arc3).augment(arc4),[vector: cx, cy])
  bezier-shape(mtx, mode, color, posn(rx, ry)).snap-axes()
end
# line()
# Represents a line going from point
#   (0,0) to point (x,y) of the given color
fun line(x     :: Number,
    y     :: Number,
    color :: Color) :
  polygon([matrix(2,2): 0, x, 0, y], outline, color, posn(x / 2, y / 2)).snap-axes()
end
# text()
# Represents the given string
#   of text, using the given
#   font size and color
fun make-text(string :: String,
    size   :: Number%(greater-than-zero),
    color  :: Color):
  text(string, size, color, posn(0,0)) #TODO: Text dimensions
end
# text-font()
# Represents the given string
#   of text with the given font
#   specification
fun make-text-font(string      :: String,
    size        :: Number%(greater-than-zero),
    color       :: Color,
    font-face   :: String, #TODO: Font Face datatype?
    font-family :: String, #TODO: Font Family datatype?
    style       :: String,
    weight      :: String,
    underline   :: Boolean):
  text-font(string, size, color, font-face, 
    font-family, style, weight, 
    underline, posn(0,0))
end
# triangle()
# Represents an upward-pointing
#   equilateral triangle
fun triangle(side-length :: Number%(greater-than-zero),
    mode        :: Mode,
    color       :: Color) :
  polygon([matrix(2,3): (side-length / 2), 0, side-length, 0, side-length * num-sin(pi / 3), side-length * num-sin(pi / 3)], 
    mode, color, posn((side-length / 2),(side-length / 2) * num-sin(pi / 3))).snap-axes()
end
# right-triangle()
# Represents a right triangle with
#   its right angle at the bottom
#   right and with leg lengths
#   side-length1 and side-length2
fun right-triangle(side-length1 :: Number%(greater-than-zero),
    side-length2 :: Number%(greater-than-zero),
    mode         :: Mode,
    color        :: Color) :
  polygon([matrix(2,3): 0, side-length1, 0,
         0, 0, side-length2], mode, color, posn(side-length1 / 2, side-length2 / 2)).snap-axes()
end
# isosceles-triangle()
# Represents an isosceles triangle,
#   where the sides are of length 
#   side-length, and the angle
#   between the two equal-length
#   sides is angle-c
fun isosceles-triangle(side-length :: Number%(greater-than-zero),
    angle-c     :: Number, # Degrees
    mode        :: Mode,
    color       :: Color) :
  r-ang = to-radians(angle-c)
  polygon([matrix(2,3):  0, (2 * (side-length * num-sin(angle-c / 2))), (side-length * num-sin(angle-c / 2)), (side-length * num-cos(angle-c / 2)), (side-length * num-cos(angle-c / 2)), 0], mode, color, posn(side-length * num-sin(r-ang / 2), side-length * num-cos(r-ang / 2))).snap-axes()
end
# triangle-sss()
# Represents a triangle with the
#   given side lengths
fun triangle-sss(side-a :: Number%(greater-than-zero),
    side-b :: Number%(greater-than-zero),
    side-c :: Number%(greater-than-zero),
    mode   :: Mode,
    color  :: Color) :
  acos = ((num-sqr(side-a) - (num-sqr(side-b) - num-sqr(side-c))) / (2 * (side-a * side-c)))
  ask:
    | (side-a > side-b) and (side-a > side-c) then:
      acosang = (((num-sqr(side-a) - num-sqr(side-b)) + num-sqr(side-c)) / 
        (2 * (side-a * side-c)))
      polygon([matrix(2,3): 0, acosang, acosang - side-c,
          side-a * num-sin(num-acos(acosang)), 0, 0], mode, color, posn(1/2 * acos, (side-a / 2) * num-sin(num-acos(acos)))).snap-axes()
    | otherwise:
      polygon([matrix(2,3): 0, side-c * ((((-1 * num-sqr(side-a)) + num-sqr(side-b)) + num-sqr(side-c)) / (2 * (side-b * side-c))), side-c, 0, side-a * num-sin(num-acos((((-1 * num-sqr(side-a)) + num-sqr(side-b)) + num-sqr(side-c)) / (2 * (side-b * side-c)))), 0], mode, color, posn(1/2 * side-c, (side-a / 2) * num-sin(num-acos(acos)))).snap-axes()
  end
end
# triangle-ass()
# Represents a triangle with the
#   given angle and two sides.(A-S-S)
fun triangle-ass(angle-a :: Number, # Degrees
   side-b  :: Number%(greater-than-zero),
    side-c  :: Number%(greater-than-zero),
    mode    :: Mode,
    color   :: Color) :
  rad-angle-a = to-radians(angle-a)
  ask:
    | angle-a < (pi / 2) then:
      polygon([matrix(2,3): 0, side-c, side-b * num-cos(rad-angle-a),
          0, 0, side-b * num-sin(rad-angle-a)], mode, color, posn(side-c / 2, (side-b * num-sin(rad-angle-a)) / 2)).snap-axes()
    | otherwise:
      polygon([matrix(2,3): num-abs(side-b * num-cos(rad-angle-a)), 0, num-abs(side-b * num-cos(rad-angle-a)) + side-c, 0, side-b * num-cos(rad-angle-a), 0], mode,color,  posn((num-abs(side-b * num-cos(rad-angle-a)) + side-c) / 2, (side-b * num-sin(rad-angle-a)) / 2)).snap-axes()
  end
end
# triangle-sas()
# Represents a triangle with the
#   given angle and two sides.(S-A-S)
fun triangle-sas(side-a  :: Number%(greater-than-zero),
    deg-angle-b :: Number, # Degrees
    side-c  :: Number%(greater-than-zero),
    mode    :: Mode,
    color   :: Color) :
  angle-b = to-radians(deg-angle-b)
  polygon([matrix(2,3): 0, side-c, side-c - (side-a * num-cos(angle-b)),
         0, 0, side-a * num-sin(angle-b)],mode,color,posn(side-c / 2, (side-a * num-sin(angle-b)) / 2)).snap-axes()
end
# triangle-ssa()
# Represents a triangle with the
#   given angle and two sides.(S-S-A)
fun triangle-ssa(side-a  :: Number%(greater-than-zero),
    side-b  :: Number%(greater-than-zero),
    deg-angle-c :: Number, # Degrees
    mode    :: Mode,
    color   :: Color) :
  angle-c = to-radians(deg-angle-c)
  side-c = num-sqrt((num-sqr(side-a) + num-sqr(side-b)) - (2 * (side-a * (side-b * num-cos(angle-c)))))
   polygon([matrix(2,3): 0, side-c, side-b * num-cos(num-asin((side-a * num-sin(angle-c)) / side-c)),  0, 0, ((side-a * (side-b * num-sin(angle-c))) / side-c)], mode, color, posn(side-c / 2, ((side-a * (side-b * num-sin(angle-c))) / side-c))).snap-axes()
end
# triangle-aas()
# Represents a triangle with the
#   given angle and two sides.(A-A-S)
fun triangle-aas(deg-angle-a :: Number, # Degrees
    deg-angle-b :: Number, # Degrees
    side-c  :: Number%(greater-than-zero),
    mode    :: Mode,
    color   :: Color) :
  angle-a = to-radians(deg-angle-a)
  angle-b = to-radians(deg-angle-b)
  csb = side-c * num-sin(angle-b)
  sinc = num-sin(pi - (angle-a + angle-b))
  ask:
    | angle-a <= (pi / 2) then:
      mtx = [matrix(2,3): 0, side-c, (csb / sinc) * num-cos(angle-a),
        0, 0, (csb / sinc) * num-sin(angle-a)]
      polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
    | otherwise:
      mtx = [matrix(2,3): num-abs((csb / sinc) * num-cos(angle-a)), 0, num-abs((csb / sinc) * num-cos(angle-a)) + side-c,
        0, (csb / sinc) * num-sin(angle-a), 0]
      polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
  end
end
  # triangle-asa()
  # Represents a triangle with the
  #   given angle and two sides.(A-S-A)
fun triangle-asa(deg-angle-a :: Number, # Degrees
                 side-b  :: Number%(greater-than-zero),
                 deg-angle-c :: Number, # Degrees
                 mode    :: Mode,
                 color   :: Color):
  angle-a = to-radians(deg-angle-a)
  angle-c = to-radians(deg-angle-c)
  bsc = side-b * num-sin(angle-c)
  sinb = num-sin(pi - (angle-a + angle-c))
  ask:
    | angle-a <= (pi / 2) then:
      mtx = [matrix(2,3): 0, (bsc / sinb), side-b * num-cos(angle-a),
        0, 0, side-b * num-sin(angle-a)]
      polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
    | otherwise:
      mtx = [matrix(2,3): num-abs(side-b * num-cos(angle-a)), 0, num-abs(side-b * num-cos(angle-a)) + (bsc / sinb),
        0, side-b * num-sin(angle-a), 0]
      polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
  end
end
  # triangle-saa()
  # Represents a triangle with the
  #   given angle and two sides.(S-A-A)
fun triangle-saa(side-a  :: Number%(greater-than-zero),
                 deg-angle-b :: Number, # Degrees
                 deg-angle-c :: Number, # Degrees
                 mode    :: Mode,
                 color   :: Color) :
  angle-b = to-radians(deg-angle-b)
  angle-c = to-radians(deg-angle-c)
  ang-a = pi - (angle-b + angle-c)
  asc = side-a * num-sin(angle-c)
  ask:
    | (angle-b + angle-c) >= (pi / 2) then:
      mtx = [matrix(2,3):  0, 0, side-a * num-cos(ang-a),
        0, (asc / num-sin(ang-a)), side-a * num-sin(ang-a)]
      polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
    | otherwise:
      mtx = [matrix(2,3): num-abs(side-a * num-cos(ang-a)), 0, num-abs(side-a * num-cos(ang-a)) + (asc / num-sin(ang-a)),
        0, side-a * num-sin(ang-a), 0]
      polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
  end
end
  # square()
  # Represents a square of the given side length
fun square(side-length :: Number%(greater-than-zero),
           mode        :: Mode,
           color       :: Color) :
  polygon([matrix(2,4):  0, 0, side-length, side-length,
      0, side-length, side-length, 0], mode, color, posn((side-length / 2), (side-length / 2))).snap-axes()
end
  # rectangle()
  # Represents a rectangle with the
  #   given two side lengths
fun rectangle(width  :: Number%(greater-than-zero),
              height :: Number%(greater-than-zero),
              mode   :: Mode,
              color  :: Color) :
  polygon([matrix(2,4):  0, 0, width, width,
      0, height, height, 0], mode, color, posn((width / 2), (height / 2))).snap-axes()
end
  # rhombus()
  # Represents a rhombus with the given
  #   side length and the given top/bottom
  #   angle
fun rhombus(side-length :: Number%(greater-than-zero),
            angle       :: Number, # Degrees
            mode        :: Mode,
            color       :: Color) :
  beta = (pi / 2) - (to-radians(angle) / 2)
      polygon([matrix(2,4): 0, side-length * num-cos(beta), 2 * (side-length * num-cos(beta)), side-length * num-cos(beta),
        side-length * num-sin(beta), 0, side-length * num-sin(beta), 2 * (side-length * num-sin(beta))], mode, color, posn((side-length * num-cos(beta)), (side-length * num-sin(beta)))).snap-axes()
end
  # star()
  # Represents a 5-pointed star of
  #   the given side length
fun star(side-length :: Number%(greater-than-zero),
         mode        :: Mode,
         color       :: Color) :
  a = pi / 5
  rmax = (2 * (side-length * num-cos(a)))
  rmin = rmax - (1.7 * side-length * num-sin(a))
  i-list = range(2,10).filter(lam(n):num-modulo(n,2) == 0 end)
  pairs = fold(lam(r,i): 
      r.push([list: ((rmax * num-cos(i * a)) + rmax), ((rmax * num-sin(i * a)) + rmax)]).push(
        [list: ((rmin * num-cos((i + 1) * a)) + rmax), ((rmin * num-sin((i + 1) * a)) + rmax)])
    end, [list: [list: ((rmin * num-cos(a)) + rmax), ((rmin * num-sin(a)) + rmax)], [list: 2 * rmax, rmax]], i-list)
  mtx = M.lists-to-matrix(pairs).transpose()
  polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
end
      
  # radial-star()
  # Represents a star with the given
  #   amount of points; the outer
  #   points will be a distance of
  #   outer from the center, the inner
  #   a distance of inner
fun radial-star(point-count :: Number%(nonzero-nat),
                outer       :: Number%(greater-than-zero),
                inner       :: Number%(greater-than-zero),
                mode        :: Mode,
                color       :: Color) :
  a = pi / point-count
      i-list = range(2,(2 * point-count)).filter(lam(n):num-modulo(n,2) == 0 end)
      pairs = fold(lam(r,i): 
          r.push([list: ((outer * num-cos(i * a)) + outer), ((outer * num-sin(i * a)) + outer)]).push(
            [list: ((inner * num-cos((i + 1) * a)) + outer), ((inner * num-sin((i + 1) * a)) + outer)])
        end, [list: [list: ((inner * num-cos(a)) + outer), ((inner * num-sin(a)) + outer)], [list: 2 * outer, outer]], i-list)
  mtx = M.lists-to-matrix(pairs).transpose()
  polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
end
  # star-sized()
  # Same as radial-star().
fun star-sized(point-count :: Number%(nonzero-nat),
               outer       :: Number%(greater-than-zero),
               inner       :: Number%(greater-than-zero),
               mode        :: Mode,
               color       :: Color) :
  radial-star(point-count, outer, inner, mode, color)
end
  # star-polygon()
  # Represents a regular star polygon,
  #   with every step-th vertex connected
fun star-polygon(side-length :: Number%(greater-than-zero),
                 point-count :: Number%(nonzero-nat),
                 step        :: Number%(nonzero-nat),
                 mode        :: Mode,
                 color       :: Color) :
  a = pi / point-count
  rmax = (2 * (side-length * num-cos(a)))
  rmin = rmax - (side-length * num-sin(a))
  i-list = range(2,(2 * point-count)).filter(lam(n):num-modulo(n,2) == 0 end)
  pairs = fold(lam(r,i): 
      r.push([list: ((rmax * num-cos(i * a)) + rmax), ((rmax * num-sin(i * a)) + rmax)]).push(
        [list: ((rmin * num-cos((i + 1) * a)) + rmax), ((rmin * num-sin((i + 1) * a)) + rmax)])
    end, [list: [list: ((rmin * num-cos(a)) + rmax), ((rmin * num-sin(a)) + rmax)], [list: 2 * rmax, rmax]], i-list)
  mtx = M.lists-to-matrix(pairs).transpose()
  polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
end
  # regular-polygon()
  # Represents a regular polygon
  #   with the given number of sides.
fun regular-polygon(length :: Number%(greater-than-zero),
                    count  :: Number%(nonzero-nat),
                    mode   :: Mode,
                    color  :: Color) :
  a = (2 * pi) / count
  r = length / (2 * num-sin(a))
  i-list = range(1,count)
  pairs = fold(lam(rst,i): 
      rst.push([list: ((r * num-cos(i * a)) + r), ((r * num-sin(i * a)) + r)])
    end, [list: [list: 2 * r, r]], i-list)
  mtx = M.lists-to-matrix(pairs).transpose()
  polygon(mtx, mode, color, mtx-center(mtx)).snap-axes()
end
  # empty-image()
  # Represents an empty image
  #   of the given size.
fun empty-image(x :: Number%(greater-than-zero),
                y :: Number%(greater-than-zero)) :
  rectangle(x,y,outline,black)
end




##################
# IMAGE PREDICATES
##################

# TODO: Probably get rid of these

fun is-regular-n-gon(n :: Number) -> (Image -> Boolean):
  doc: "Returns a Predicate which returns true if the given image is a regular n-gon"
  about-eq = lam(a, b): num-abs(a - b) <= num-expt(10,-11) end
  lam(i :: Image):
    # dispMtx represents the displacement vectors
    #   of each point in the image's matrix (i.e. it's sides)
    # If the magnitude of each displacement vector is the same
    #   and their dot products are equal, then they all have the
    #   the same angles between one another. Thus, the image must be
    #   a regular polygon.
    shiftedMtx = M.vectors-to-matrix(i.matrix.to-vectors().drop(i.matrix.cols - 1) + i.matrix.to-vectors().take(i.matrix.cols - 1))
    dispMtx = i.matrix - shiftedMtx
    vecs = dispMtx.to-vectors()
    firstDot = M.dot(vecs.first, vecs.get(1))
    firstMag = M.magnitude(vecs.first)
    len = vecs.length()
    ((len == n) and is-polygon(i)) and
    ((fold(lam(acc, v): acc and about-eq(v,firstMag) end, true, vecs.map(M.magnitude))) and
    (for fold(acc from true, j from range(0,len)):
        acc and about-eq(M.dot(vecs.get(j), vecs.get(num-modulo(j + 1, len))), firstDot)
    end))
  end
end

fun is-triangle(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a polygon"
  # Polygon with 3 Vertices
  is-polygon(img) and (img.matrix.cols == 3)
end

is-equilateral-triangle = is-regular-n-gon(3)

fun is-rectangle(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a rectangle"
  is-polygon(img) and (img.matrix.cols == 4)
end

is-square = is-regular-n-gon(4)

fun is-pentagon(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a pentagon"
  is-polygon(img) and (img.matrix.cols == 5)
end

is-regular-pentagon = is-regular-n-gon(5)

fun is-hexagon(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a hexagon"
  is-polygon(img) and (img.matrix.cols == 6)
end

is-regular-hexagon = is-regular-n-gon(6)

fun is-ellipse(img :: Image) -> Boolean:
  doc: "Returns true if the given image is an ellipse"
  # Using Properties of the Bezier Representation of Ellipses
  about-eq = lam(a, b): num-abs(a - b) <= num-expt(10,-11) end
  dispMtxMags = (img.matrix - (img.matrix.submatrix(range(0,img.matrix.rows), 
      [list: img.matrix.cols - 1] ).augment(
      img.matrix.submatrix(range(0,img.matrix.rows),range(0,(img.matrix.cols - 1)))))).to-vectors().map(M.magnitude)
  
  (is-bezier-shape(img) and (img.matrix.cols == 13)) and
  (for fold2(acc from true, v from dispMtxMags.take(6), w from dispMtxMags.reverse().take(6)):
      acc and about-eq(v,w)
    end)
end

fun is-circle(img :: Image) -> Boolean:
  doc: "Returns true if the given image is a circle"
  b = points-bounding-box(img.matrix)
  is-ellipse(img) and (b.width == b.height)
end



##########################
# TRANSFORMATION FUNCTIONS
##########################



fun get-bounding-box-mtx(img :: Image) -> M.Matrix:
  doc: "Returns the bounding box's matrix for the given image"
  cases(Image) img:
    | rotated-image(angle, image, center, _,_) => 
      rst = get-bounding-box-mtx(image)
      affine-transform-matrix(rotation-matrix(angle),rst,mtx-center(rst))
    | scaled-image(x-scale,y-scale,image,_,_,_)=>
      rst = get-bounding-box-mtx(image)
      affine-transform-matrix(scale-xy-matrix(x-scale,y-scale),rst,mtx-center(rst))
    | text(_,_,_,_) => raise("Not yet implemented")
    | text-font(_,_,_,_,_,_,_,_,_) => raise("Not yet implemented")
    | else => img.to-matrix()
  end
end

fun bounding-box(img :: Image) -> Box:
  points-bounding-box(get-bounding-box-mtx(img))
end

fun snap-trans(img :: Image) -> M.Vector:
  rws = img.matrix.to-lists()
  min-x = rws.first.sort().first
  min-y = rws.get(1).sort().first
  trans-x = if (min-x > 0):
    num-abs(min-x)
  else:
    -1 * min-x
  end
  trans-y = if (min-y > 0):
    num-abs(min-y)
  else:
    -1 * min-y
  end
  [vector: trans-x, trans-y]
end

fun snap-axes(img :: Image) -> Image:
  if is-compound-image(img):
    t-trans = snap-trans(img.top)
    b-trans = snap-trans(img.bottom)
    c-trans = map2(num-max,t-trans,b-trans)
    img.translate(c-trans)
  else:
    img.translate(snap-trans(img))
  end
end
    

###########################
# IMAGE COMBINING FUNCTIONS
###########################

# Begin Helper Functions

fun new-center(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Position:
  doc: "Returns the center coordinate of the first given image placed on the second at the given position"
  nb = new-box(i1,x,y,i2, i1.center)
  posn(nb.width / 2, nb.height / 2)
end

# TODO: Find a better fix
# (This is temporary)
fun fix-overlay-center(i1 :: Image, at :: Position, old-center :: Position) -> Position:
  doc: "Returns the adjusted center for overlays"
  shifted-top = i1.translate([vector: (-1 * i1.center.x) + at.x, (-1 * i1.center.y) + at.y])
  sv = shifted-top.snap-vec()
  posn(old-center.x + num-max(0,sv.first),
    old-center.y + num-max(0,sv.get(1)))
end
  

# End Helper Functions

# Begin Overlay Functions
fun overlay(i1 :: Image, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second"
  i2-no-pin = i2.remove-pinhole()
  compound-image(i1.remove-pinhole(), i2-no-pin.center, i2-no-pin, i2-no-pin.center).snap-axes()
end

fun overlay-pinhole(i1 :: Image, i2 :: Image) -> Image:
  doc: "Overlays the first image onto the second using their pinholes"
  #Note: Default pinhole is true center
  #TODO: Find better fix than this translation vector
  tc = if is-clipped-image(i1): i1.pair.center else: i1.center end
  comp-top = i1.translate([vector: i2.center.x - tc.x, i2.center.y - tc.y])
  sv = compound-image(comp-top, i2.center, i2, i2.center).snap-vec()
  compound-image(comp-top.translate(sv), i2.center, i2.translate(sv), translate-posn(i2.center,sv)).snap-axes()
end

fun overlay-align(xp :: X-Place, yp :: Y-Place, ri1 :: Image, ri2 :: Image) -> Image:
  doc: "Overlays the first image onto the second with the given alignments"
  i1 = ri1.remove-pinhole()
  i2 = ri2.remove-pinhole()
  tb = i1.get-box()
  bb = i2.get-box()
  xpos = cases(X-Place) xp:
    | x-left => tb.width / 2
    | x-center => i2.center.x
    | x-right => bb.width - (tb.width / 2)
  end
  ypos = cases(Y-Place) yp:
    | y-top => tb.height / 2
    | y-center => i2.center.y
    | y-bottom => bb.height - (tb.height / 2)
  end
  new-c = new-center(i1,xpos,ypos,i2)
  compound-image(i1, posn(xpos, ypos), i2, new-c).snap-axes()
end

fun overlay-offset(ri1 :: Image, x :: Number, y :: Number, ri2 :: Image) -> Image:
  doc: "Overlays the first image onto the second after shifting the second x pixels to the right and y down"
  i1 = ri1.remove-pinhole()
  i2 = ri2.remove-pinhole()
  at = posn(i2.center.x - x, i2.center.y - y)
  new-c = new-center(i1,at.x,at.y,i2)
  compound-image(i1, at, i2, new-c).snap-axes()
end

fun overlay-align-offset(xp :: X-Place, yp :: Y-Place, ri1 :: Image, x :: Number, y :: Number, ri2 :: Image) -> Image:
  doc: "Overlays the first image onto the second with the given alignments after shifting it x pixels to the right and y down"
  i1 = ri1.remove-pinhole()
  i2 = ri2.remove-pinhole()
  tb = i1.get-box()
  bb = i2.get-box()
  xpos = cases(X-Place) xp:
    | x-left => (tb.width / 2) - x
    | x-center => (i2.center.x - x)
    | x-right => (bb.width - (tb.width / 2)) - x
  end
  ypos = cases(Y-Place) yp:
    | y-top => (tb.height / 2) - y
    | y-center => (i2.center.y - y)
    | y-bottom => (bb.height - (tb.height / 2)) - y
  end
  new-c = new-center(i1,xpos,ypos,i2)
  compound-image(i1, posn(xpos, ypos), i2, new-c).snap-axes()
end

fun overlay-xy(ri1 :: Image, x :: Number, y :: Number, ri2 :: Image) -> Image:
  # Identical to underlay-xy(i2,(-1 * x), (-1 * y), i1)
  doc: "Overlays the first image onto the second. The images are initially lined up on their upper-left corners and then the bottom one is shifted to the right by x to and down by y."
  i1 = ri1.remove-pinhole()
  i2 = ri2.remove-pinhole()
  tb = i1.get-box()
  # I never understood why this gets flipped....
  at = posn((tb.width / 2) - x, (tb.height / 2) - y)
  new-c = new-center(i1, at.x, at.y, i2)
  compound-image(i1, at, i2, new-c).snap-axes()
end

# End Overlay Functions

# Begin Underlay Functions

# (IMHO Bug fixes will be easier if these are wrappers for overlay functions)
# If there's some performance loss or something because of this, let me know

fun underlay(i1 :: Image, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second (like overlay, but in reverse order)"
  overlay(i2, i1)
end

fun underlay-pinhole(i1 :: Image, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second using their pinholes"
  overlay-pinhole(i2,i1)
end

fun underlay-align(xp :: X-Place, yp :: Y-Place, i1 :: Image, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second with the given alignments"
  overlay-align(xp, yp, i2, i1)
end


fun underlay-offset(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second, after offsetting it right and down by the given amount"
  overlay-offset(i2, (-1 * x), (-1 * y), i1)
end

fun underlay-align-offset(xp :: X-Place, yp :: Y-Place, i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second with the given alignments, after offsetting it right and down by the given amount"
  overlay-align-offset(xp, yp, i2, (-1 * x), (-1 * y), i1)
end

fun underlay-xy(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Underlays the first image beneath the second by aligning their top left corners and shifting the second right and down by the given amount"
  overlay-xy(i2, (-1 * x), (-1 * y), i1)
end

fun beside(ri1 :: Image, ri2 :: Image) -> Image:
  doc: "Places the second image next to the first, with their centers vertically aligned"
  i1 = ri1.remove-pinhole()
  i2 = ri2.remove-pinhole()
  fb = i1.get-box()
  sb = i2.get-box()
  at = posn(fb.width + (sb.width / 2), i1.center.y)
  new-c = new-center(i2,at.x,at.y,i1)
  compound-image(i2,at,i1,new-c).snap-axes()
end

fun beside-list(imgs :: List<Image>) -> Image:
  doc: "Places the list of images next to one another, with the first image on the left"
  swapped = lam(i1, i2): beside(i2, i1) end
  imgs.rest.foldl(swapped,imgs.first)
end

fun beside-align(yp :: Y-Place, ri1 :: Image, ri2 :: Image) -> Image:
  doc: "Places the second image next to the first, with the given vertical alignment"
  i1 = ri1.remove-pinhole()
  i2 = ri2.remove-pinhole()
  fb = i1.get-box()
  sb = i2.get-box()
  xpos = fb.width + (sb.width / 2)
  ypos = cases(Y-Place) yp:
    | y-top => (sb.height / 2)
    | y-center => i1.center.y
    | y-bottom => fb.height - (sb.height / 2)
  end
  new-c = new-center(i2, xpos, ypos, i1)
  compound-image(i2,posn(xpos,ypos),i1,new-c).snap-axes()
end

fun beside-align-list(yp :: Y-Place, imgs :: List<Image>) -> Image:
  doc: "Places the list of images next to one another with the given alignment, with the first image on the left"
  with-yp = lam(i2, i1): beside-align(yp, i1, i2) end
  imgs.rest.foldl(with-yp,imgs.first)
end

fun above(ri1 :: Image, ri2 :: Image) -> Image:
  doc: "Places the first image above the second, with their centers horizontally aligned"
  i1 = ri1.remove-pinhole()
  i2 = ri2.remove-pinhole()
  sb = i1.get-box()
  at = posn(i2.center.x, (-1 * (sb.height / 2)))
  new-c = new-center(i1,at.x,at.y,i2)
  compound-image(i1,at,i2,new-c).snap-axes()
end

fun above-list(imgs :: List<Image>) -> Image:
  doc: "Places the list of images on top of one another, with the first image on the top"
  swapped = lam(i1, i2): above(i2, i1) end
  imgs.rest.foldl(swapped, imgs.first)
end

fun above-align(xp :: X-Place, ri1 :: Image, ri2 :: Image) -> Image:
  doc: "Places the first image above the second, with the given horizontal alignment"
  i1 = ri1.remove-pinhole()
  i2 = ri2.remove-pinhole()
  fb = i2.get-box()
  sb = i1.get-box()
  xpos = cases(X-Place) xp:
    | x-left => (sb.width / 2)
    | x-center => i2.center.x
    | x-right => fb.width - (sb.width / 2)
  end
  ypos = (-1 * (sb.height / 2))
  new-c = new-center(i1,xpos,ypos,i2)
  compound-image(i1, posn(xpos, ypos), i2, new-c).snap-axes()
end

fun above-align-list(xp :: X-Place, imgs :: List<Image>) -> Image:
  doc: "Places the list of images on top of one another with the given alignment, with the first image on top"
  with-xp = lam(i1, i2): above-align(xp, i2, i1) end
  #len = imgs.length()
  #imgs.take(len - 1).foldl(with-xp, imgs.last())
  imgs.rest.foldl(with-xp, imgs.first)
end

fun empty-scene(x :: Number%(greater-than-zero),
                y :: Number%(greater-than-zero)) :
  overlay(rectangle(x,y,outline,black), rectangle(x,y,solid,white))
end

fun colored-empty-scene(x :: Number%(greater-than-zero),
                y :: Number%(greater-than-zero),
                k :: Color) :
  overlay(rectangle(x,y,outline,black), rectangle(x,y,solid,k))
end

fun place-image(i1 :: Image, x :: Number, y :: Number, i2 :: Image) -> Image:
  doc: "Places the first image onto the second, clipping it so that it is no larger than the bottom"
  ri1 = i1.remove-pinhole()
  ri2 = i2.remove-pinhole()
  if not(is-clipped-image(ri2)):
    clipped-image(compound-image(ri1, posn(x,y), ri2, ri2.center),false)
  else:
    # Combine the tops to avoid unneeded mask propogation
    trans-vec = [vector: ri2.pair.at.x - ri2.pair.top.center.x, 
      ri2.pair.at.y - ri2.pair.top.center.y]
    basis = ri2.pair.top.translate(trans-vec).coord-zero()
    comb-at = posn(x - basis.x, y - basis.y)
    new-top = compound-image(ri1, comb-at,ri2.pair.top,new-center(ri1,comb-at.x,comb-at.y,ri2.pair.top))
    diff-c = posn(ri2.pair.top.center.x - new-top.center.x, 
                  ri2.pair.top.center.y - new-top.center.y)
    new-at = posn(ri2.pair.at.x - diff-c.x, ri2.pair.at.y - diff-c.y)
    clipped-image(compound-image(new-top, new-at, ri2.pair.bottom, ri2.pair.center),ri2.hidden-mask)
  end
end

fun place-images(imgs :: List<Image>, posns :: List<Position>, base :: Image) -> Image:
  doc: "Places the given list of images onto the given base image (the first being on top) at the given positions"
  placelam = lam(acc, i, p): place-image(i, p.x, p.y, acc) end
  fold2(placelam,base,imgs,posns)
end

fun place-image-align(i1 :: Image, x :: Number, y :: Number, xp :: X-Place, yp :: Y-Place, i2 :: Image):
  tb = i1.get-box()
  xpos = cases(X-Place) xp:
    | x-left => (tb.width / 2) + x
    | x-center => x
    | x-right => (-1 * (tb.width / 2)) + x
  end
  ypos = cases(Y-Place) yp:
    | y-top => (tb.height / 2) + y
    | y-center => y
    | y-bottom => (-1 * (tb.height / 2)) + y
  end
  place-image(i1, xpos, ypos, i2)
end

############
# OTHER IMAGE FUNCTIONS
############

fun frame(i :: Image) -> Image:
  doc: "Returns the given image with a black frame around it"
  bb = i.get-box()
  overlay(rectangle(bb.width, bb.height, outline, black), i)
end


############
# SVG RENDERING FUNCTIONS
############


fun num-inexact-string(n :: Number) -> String:
  doc: "Returns a string with a decimal representation of the given number"
  num-to-string-digits(num-exact(n), 10)
end

fun point-to-string(pt :: Position):
  num-inexact-string(pt.x) + "," + num-inexact-string(pt.y) + " "
where:
  point-to-string(posn(25,34)) is "25,34 "
end

fun draw-polygon(i :: Image%(is-polygon)) -> XML.Element:
  doc: "Returns the <polygon> tag corresponding to the given polygon"
  
  points = XML.attribute("points", XML.atomic(for fold(acc from "", p from matrix-to-posns(i.matrix)):
    acc + point-to-string(p)
  end))
  
  col-str = "rgba(" 
    + num-tostring(i.color.red) + "," 
    + num-tostring(i.color.green) + "," 
    + num-tostring(i.color.blue) + "," 
    + num-tostring(i.color.alpha) + ")"
  
  style-str = cases(Mode) i.mode:
    | solid => "fill:" + col-str + ";"
    | outline => "stroke:" + col-str + ";stroke-width: 2; fill: none;"
  end
  
  style = XML.attribute("style", style-str)
  XML.tag("polygon", [list: points, style], empty)
end


fun draw-bezier-shape(i :: Image%(is-bezier-shape)) -> XML.Element:
  doc: "Returns the <path> tag corresponding to the given bezier-curve-defined shape"
  # USAGE: (note: i.matrix.cols % 3 == 1)
  # The first position in the matrix is the move-to point
  #   and the remaining ones are Cubic Bezier control points
  # IF YOU DON'T KNOW WHAT THAT MEANS YOU SHOULDN'T BE CALLING THIS
  fun curve-string(lst :: List<Position>):
    if not(num-modulo(lst.length(),3) == 0):
      raise("Invalid Bezier Shape")
    else:
      fun recur-string(acc, l :: List<Position>):
        cases(List) l:
          | empty => acc
          | link(f,r) => recur-string(acc + ("C " + fold(string-append, "",map(point-to-string,l.take(3)))), l.drop(3))
        end
      end
      recur-string("",lst)
    end
  end
  
  raw-pts = matrix-to-posns(i.matrix)
   
  points = XML.attribute("d", XML.atomic("M" + (point-to-string(raw-pts.first) + curve-string(raw-pts.rest))))
  
  col-str = "rgba(" 
    + num-tostring(i.color.red) + "," 
    + num-tostring(i.color.green) + "," 
    + num-tostring(i.color.blue) + "," 
    + num-tostring(i.color.alpha) + ")"
  
  style-str = cases(Mode) i.mode:
    | solid => "fill:" + col-str + ";"
    | outline => "stroke:" + col-str + ";stroke-width: " + num-tostring(DEFAULT_OUTLINE_WIDTH) + "; fill: none;"
  end
  
  style = XML.attribute("style", style-str)
  XML.tag("path", [list: points, style], empty)
end

fun wrap-and-name(prefix :: Number, n :: Number, elt :: XML.Element) -> XML.Element:
  id-str = XML.attribute("id", XML.atomic(num-tostring(prefix) + "_" + num-tostring(n)))
  shape-id-str = XML.attribute("id", XML.atomic(num-tostring(prefix) + "_" + num-tostring(n) + "_shape"))
  new-elt = XML.tag(elt.name, elt.attributes + [list: shape-id-str], elt.elts)
  XML.tag("clipPath", [list: id-str], [list: new-elt])
end

fun get-clip-intersect(prefix :: Number, clips :: List<XML.Element>, width :: Number, height :: Number) -> List<XML.Element>:
  len = clips.length()
  when len == 0:
    raise("Cannot clip image without clip")
  end
  id-att = lam(num): XML.attribute("id", XML.atomic(num-tostring(prefix) + "_" + num-tostring(num) + "_clip")) end
  first-path-att = lam(num): XML.attribute("clip-path", XML.atomic("url(#" + num-tostring(prefix) + "_" + num-tostring(num) + ")")) end
  path-att = lam(num): XML.attribute("clip-path", XML.atomic("url(#" + num-tostring(prefix) + "_" + num-tostring(num) + "_clip)")) end
  shape-id = lam(num): num-tostring(prefix) + "_" + num-tostring(num) + "_shape" end
  use-tag = lam(num): XML.tag("use", [list: 
        XML.attribute("x",XML.atomic("0")), 
        XML.attribute("y",XML.atomic("0")), 
        XML.attribute("width",XML.atomic(width)), 
        XML.attribute("height",XML.atomic(height)), 
        XML.attribute("xlink:href",XML.atomic("#" + shape-id(num)))], empty) 
  end
  if len == 1:
    [list: XML.tag("clipPath", [list: id-att(0)], [list: use-tag(0)])]
  else:
    start = XML.tag("clipPath", [list: id-att(len - 2), first-path-att(len - 1)], [list: use-tag(len - 2)])
    (for fold(acc from [list: start], n from range(0,len - 2).reverse()):
        link(XML.tag("clipPath", [list: id-att(n), path-att(n + 1)], [list: use-tag(n)]), acc)
      end).reverse()
  end
end

data ClipInfo:
  | clip-pair(defs :: XML.Element, useClip :: String)
end

fun add-clip(name :: String, to :: XML.Element) -> XML.Element:
  XML.tag(to.name, to.attributes + [list: XML.attribute("clip-path",XML.atomic(name))], to.elts)
end

fun get-clip(i :: Image%(is-clipped-image), fit-all :: Boolean) -> ClipInfo:
  doc: "Returns the clip for the given clipped image"
  bbox = i.pair.get-box()
  shapes = draw-prerendered-svg(i.pair.bottom, fit-all)
  prefix = num-random(10000) # TODO: Find a better way to avoid n.s. collisions
  wrapped = for map2(n from range(0,shapes.length()), elt from shapes):
    wrap-and-name(prefix, n, elt)
  end
  defs = XML.tag("defs", empty, wrapped + get-clip-intersect(prefix, wrapped, bbox.width, bbox.height))
  to-use = defs.elts.last().attributes.first.value.val # That's a mouthful
  clip-pair(defs, "url(#" + to-use + ")")
end

fun draw-prerendered-svg(i :: Image, fit-all :: Boolean) -> List<XML.Element>:
  doc: "Returns the list of XML elements corresponding to the given pre-rendered image"
  cases(Image) i:
    | compound-image(top, at, bottom, _) => 
      dy = if fit-all: num-max(0, bottom.snap-vec().get(1)) else: 0 end
      # basis needed for translating from relative positioning
      # to absolute positioning
      basis = bottom.coord-zero()
      top-basis = top.coord-zero()
      true-at = posn(at.x + basis.x, at.y + basis.y)
      trans-top = if (is-clipped-image(top)): 
      top.translate([vector: (true-at.x - top.pair.center.x), 
            (true-at.y - top.pair.center.y) + dy]) 
      else: top.translate([vector: (true-at.x - top.center.x), 
            (true-at.y - top.center.y) + dy]) 
      end
      top-vec = if fit-all: trans-top.snap-vec() else: [vector: 0, 0] end
      top-dx = num-max(0, top-vec.first)
      top-dy = num-max(0, top-vec.get(1))
      draw-prerendered-svg(bottom.translate([vector: top-dx, dy + top-dy]), fit-all).append(
        draw-prerendered-svg(trans-top.translate([vector: top-dx, top-dy]), fit-all))
      
    | clipped-image(pair, hide-bottom) =>
      clip = get-clip(i, fit-all)
      clip-add = lam(e): add-clip(clip.useClip, e) end
      dy = if fit-all: num-max(0, pair.bottom.snap-vec().get(1)) else: 0 end
      basis = pair.bottom.coord-zero()
      true-at = posn(pair.at.x + basis.x, pair.at.y + basis.y)
      trans-top = if (is-clipped-image(pair.top)): 
      pair.top.translate([vector: true-at.x - pair.top.pair.center.x, 
            (true-at.y - pair.top.pair.center.y) + dy]) 
      else: pair.top.translate([vector: true-at.x - pair.top.center.x, 
            (true-at.y - pair.top.center.y) + dy]) 
      end
      if not(hide-bottom):
        [list: clip.defs] + map(clip-add, draw-prerendered-svg(pair.bottom.translate([vector: 0, dy]), fit-all).append(draw-prerendered-svg(trans-top, false)))
      else:
        [list: clip.defs] + map(clip-add, draw-prerendered-svg(trans-top, false))
      end
      
    | else =>
      if is-polygon(i):
        [list: draw-polygon(i)]
      else:
        [list: draw-bezier-shape(i)]
      end
  end
end

fun list-min<X>(lst :: List<X>) -> X:
  doc: "Returns the minimal element of the given list"
  retless = lam(a,b): if a < b: a else: b end end
  cases(List) lst:
    | link(_,_) => fold(retless, lst.first, lst.rest)
    | empty => raise("Cannot find the least element of an empty list")
  end
where:
  list-min([list: 4, 2, 6, 3, 7, 4, 1, 3, 8]) is 1
  list-min([list: -30, 2, 5, 2, 6]) is -30
end


fun draw-svg(i :: Image) -> XML.Element:
  doc: "Returns an SVG element representation of the given image"
  # Current status: Spits out <svg> tag in REPR. Copy/paste somewhere
  #   such as http://scriptdraw.com/ to view, or use a Tampermonkey
  #   script made by Philip (email (see top) for a copy)
  pre = draw-prerendered-svg(i, true) # Returns all <polygon> and <path> tags
  b = i.svg-size()
  ht = XML.attribute("height", num-exact(b.height))
  wd = XML.attribute("width", num-exact(b.width))
  attrs = 
  if ((is-polygon(i) or is-bezier-shape(i)) and (i.mode == outline)): 
    [list: wd, ht, XML.attribute("style", "overflow:visible;")]
  else:
    [list: wd, ht]
  end
  XML.tag("svg", attrs, pre)
end

